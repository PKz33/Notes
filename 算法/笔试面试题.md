## 笔试面试题
- **查找第K大的数字**  
1. 题目描述：在含有N个数的乱序数组`arr`中，就地查找第K大的数，若找到则返回该数在数组中的索引    
2. 解题思路：  
a. 执行一次快排后得到一个基准索引，记为`base`（左边的数比数组中该索引存储的数小，右边的数比数组中该索引存储的数大）  
b. 若`base == k-1`，则`arr[base]`既为第K大的数，返回`base`的值      
c. 若`base < k-1`，则第K大的数位于`base`右边部分，则只对右边部分继续进行查找     
d. 若`base > k-1`，则第K大的数位于`base`左边部分，则只对左边部分继续进行查找   
3. 代码实现：  
```
  // 时间复杂度O(n)

  public int partition(int[] arr, int low, int high) {
    int tmp = arr[low];
    while(low < high) {
      while(arr[high] >= tmp && low < high) {
        high--;
      }
      arr[low] = arr[high];
      while(arr[low] <= tmp && low < high) {
        low++;
      }
      arr[high] = arr[low];
    }
    arr[low] = tmp;
    return low;
  }
  
  public int find_k(int k, int[] arr, int low, int high) {
    if(arr.length < k || k <= 0)
      return -1;
    int base = partition(arr, low, high);
    if(base == k-1) {
      return base;
    }else if(base < k-1) {
      return find_k(k, arr, base + 1, high);
    }else {
      return find_k(k, arr, low, base - 1);
    }
  } 
```
- **二分查找**  
1. 非递归：  
```
  public int binSear(int[] arr, int key) {
    if(arr.length == 0 || arr == null)
      return -1;
      int low = 0, high = arr.length - 1;
      while(low <= high) {
        int mid = (low + high) / 2;
        if(arr[mid] == key) 
          return mid;
        else if(arr[mid] > key)  
          high = mid - 1;
        else 
          low = m + 1;
      }
      return -1;
  }
```  
2. 递归：  
```
  public int binSear(int[] arr, int key, int low, int high) {
    if(low <= high) {
      int mid = (low + high) / 2;
      if(arr[mid] == key)
        return mid;
      else if(arr[mid] < key) 
        return binSear(arr, key, mid + 1, high);
      else
        return binSear(arr, key, low, mid - 1);
    }
    return -1;
  }
```
- **最大的K个数**  
1. 问题描述：输入n个数，找出最大的K个数  
2. 解题思路：维护一个大小为K的最小堆；也可以借鉴快排查找第K大数的思想查找出结果
3. 代码实现：
```
  public ArrayList<Integer> findKs(int[] arr, int k) {
    if(arr.length < k || k <= 0)
      return new ArrayList<Integer>();
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    for(int n : arr){
      heap.add(n);
      if(heap.size() > k)
        heap.poll();
    }
    return new ArrayList<Integer>(heap);
  }
```  
4. 如果输入数据为海量数据  
a. `Hash`法去重  
b. 分治&归并  
c. 每个被分治的局部数据内部，采用快排思想找出局部最大的K个数（也可以采用最小堆法），然后将所有局部的结果归并，再查找一次  
d. 若数据以流的方式输入（只在内存流过一次），则采用最小堆法最合适   
- **回文游戏**  
1. 题目描述：Cassidy和Eleanore一起玩了一个回文游戏，游戏规则：给出一个仅包含小写字母的字符串S，在每一个人的回合中，她们会进行两个操作：1) 尝试重新排列这个字符串，如果可以把这个字符串排列成回文字符串，则立即获胜。2) 否则，她们必须删掉字符串中的一个字符。已知，Cassidy先手，在两个人都采取最佳策略的情况下，谁可以获胜  
2. 代码实现：   
```
    public static String whoWillWin(String str){
        int[] arr = new int[26];
        char[] chars = str.toCharArray();
        for(char c : chars){
            arr[c - 'a']++;
        }
        int odd = 0;
        for(int num : arr){
            if((num & 1) == 1){
                odd++;
            }
        }
        if(odd > 0){
            odd -= 1;
        }
        return odd % 2 == 0 ? "Cassidy" : "Eleanore";
    }
```
- **回合制游戏**   
1. 题目描述：聚力会提高你下个回合攻击的伤害。攻击会对敌人造成一定量的伤害。如果你上个回合使用了聚力，那这次攻击会对敌人造成buffedAttack点伤害。否则，会造成normalAttack点伤害。给出血量HP和不同攻击的伤害，buffedAttack和normalAttack，返回你能杀死敌人的最小回合数   
2. 代码实现：
```
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int hp = sc.nextInt();
            int natk = sc.nextInt();
            int batk = sc.nextInt();
            if(batk >= natk * 2){
                int res = hp % batk;
                if(res > 0 && res <= natk){
                    res = hp / batk * 2 + 1;
                    System.out.println(res);
                }else{
                    res = (hp - 1) / batk * 2 + 2;
                    System.out.println(res);
                }
            }else{
                int res = (hp - 1) / natk + 1;
                System.out.println(res);
            }
        }
    }
```   
- **两两配对差值最小**   
1. 题目描述：给定一个长度为偶数的数组arr，将该数组中的数字两两配对并求和，在这些和中选出最大和最小值，请问该如何两两配对，才能让最大值和最小值的差值最小      
2. 代码实现：   
```
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            int[] arr = new int[n];
            for(int i = 0;i < n;i++){
                arr[i] = sc.nextInt();
            }
            Arrays.sort(arr);
            int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
            for(int i = 0, j = n - 1;i < n / 2;i++, j--){
                max = Math.max(max, arr[i] + arr[j]);
                min = Math.min(min, arr[i] + arr[j]);
            }
            System.out.println(max - min);
        }
    }
```
- **查询最少有2门课程都>=60分的学生信息**  
```
create table t_student(
	s_id int comment '学生ID',
	s_name varchar(20) comment '学生姓名',
	s_gender int comment '学生性别 0-男,1-女'
) comment '学生表';

create table t_score(
	sc_id int comment '成绩ID',
	s_id int comment '学生ID',
	course_name varchar(20) comment '课程名称',
	score numeric(10,0) comment '成绩'	
) comment '成绩表';

select st.* from t_student st, t_score sc where st.s_id = sc.s_id and sc.score >= 60 group by sc.s_id having count(*) >= 2;
```  
- **查询学生最多的省份名字**  
```
select province, count(*) as c from stu group by province order by c desc limit 1;
```
