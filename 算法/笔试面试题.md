## 笔试面试题
- **查找前K大的数字**  
1. 题目描述：在含有N个数的乱序数组`arr`中，就地查找第K大的数，若找到则返回该数在数组中的索引    
2. 解题思路：  
a. 执行一次快排后得到一个基准索引，记为`base`（左边的数比数组中该索引存储的数小，右边的数比数组中该索引存储的数大）  
b. 若`base == k-1`，则`arr[base]`既为第K大的数，返回`base`的值
c. 若`base < k-1`，则第K大的数位于`base`右边部分，则只对右边部分继续进行查找  
d. 若`base > k-1`，则第K大的数位于`base`左边部分，则只对左边部分继续进行查找   
3. 代码实现：  
```
  // 时间复杂度O(n)

  public int partition(int[] arr, int low, int high) {
    int tmp = arr[low];
    while(low < high) {
      while(arr[high] >= tmp && low < high) {
        high--;
      }
      arr[low] = arr[high];
      while(arr[low] <= tmp && low < high) {
        low++;
      }
      arr[high] = arr[low];
    }
    arr[high] = tmp;
    return high;
  }
  
  public int find_k(int k, int[] arr, int low, int high) {
    int base = partition(arr, low, high);
    if(base == k-1) {
      return base;
    }else if(base < k-1) {
      return find_k(k, arr, base + 1, high);
    }else {
      return find_k(k, arr, low, base - 1);
    }
  } 
```
- **二分查找**  
1. 非递归：  
```
  public int binSear(int[] arr, int key) {
    if(arr.length == 0 || arr == null)
      return -1;
      int low = 0, high = arr.length - 1;
      while(low <= high) {
        int mid = (low + high) / 2;
        if(arr[mid] == key) 
          return mid;
        else if(arr[mid] > key)  
          high = mid - 1;
        else 
          low = m + 1;
      }
      return -1;
  }
```  
2. 递归：  
```
  public int binSear(int[] arr, int key, int low, int high) {
    if(low <= high) {
      int mid = (low + high) / 2;
      if(arr[mid] == key)
        return mid;
      else if(arr[mid] < key) 
        return binSear(arr, key, mid + 1, high);
      else
        return binSear(arr, key, low, mid - 1);
    }
    return -1;
  }
```
