## 笔试面试题
- **查找第K大的数字**  
1. 题目描述：在含有N个数的乱序数组`arr`中，就地查找第K大的数，若找到则返回该数在数组中的索引    
2. 解题思路：  
a. 执行一次快排后得到一个基准索引，记为`base`（左边的数比数组中该索引存储的数小，右边的数比数组中该索引存储的数大）  
b. 若`base == k-1`，则`arr[base]`既为第K大的数，返回`base`的值
c. 若`base < k-1`，则第K大的数位于`base`右边部分，则只对右边部分继续进行查找  
d. 若`base > k-1`，则第K大的数位于`base`左边部分，则只对左边部分继续进行查找   
3. 代码实现：  
```
  // 时间复杂度O(n)

  public int partition(int[] arr, int low, int high) {
    int tmp = arr[low];
    while(low < high) {
      while(arr[high] >= tmp && low < high) {
        high--;
      }
      arr[low] = arr[high];
      while(arr[low] <= tmp && low < high) {
        low++;
      }
      arr[high] = arr[low];
    }
    arr[high] = tmp;
    return high;
  }
  
  public int find_k(int k, int[] arr, int low, int high) {
    if(arr.length < k || k <= 0)
      return -1;
    int base = partition(arr, low, high);
    if(base == k-1) {
      return base;
    }else if(base < k-1) {
      return find_k(k, arr, base + 1, high);
    }else {
      return find_k(k, arr, low, base - 1);
    }
  } 
```
- **二分查找**  
1. 非递归：  
```
  public int binSear(int[] arr, int key) {
    if(arr.length == 0 || arr == null)
      return -1;
      int low = 0, high = arr.length - 1;
      while(low <= high) {
        int mid = (low + high) / 2;
        if(arr[mid] == key) 
          return mid;
        else if(arr[mid] > key)  
          high = mid - 1;
        else 
          low = m + 1;
      }
      return -1;
  }
```  
2. 递归：  
```
  public int binSear(int[] arr, int key, int low, int high) {
    if(low <= high) {
      int mid = (low + high) / 2;
      if(arr[mid] == key)
        return mid;
      else if(arr[mid] < key) 
        return binSear(arr, key, mid + 1, high);
      else
        return binSear(arr, key, low, mid - 1);
    }
    return -1;
  }
```
- **最大的K个数**  
1. 问题描述：输入n个数，找出最大的K个数  
2. 解题思路：维护一个大小为K的最小堆；也可以借鉴快排查找第K大数的思想查找出结果
3. 代码实现：
```
  public ArrayList<Integer> findKs(int[] arr, int k) {
    if(arr.length < k || k <= 0)
      return new ArrayList<Integer>();
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    for(int n : arr){
      heap.add(n);
      if(heap.size() > k)
        heap.poll();
    }
    return new ArrayList<Integer>(heap);
  }
```  
4. 如果输入数据为海量数据  
a. `Hash`法去重  
b. 分治&归并  
c. 每个被分治的局部数据内部，采用快排思想找出局部最大的K个数（也可以采用最小堆法），然后将所有局部的结果归并，再查找一次  
d. 若数据以流的方式输入（只在内存流过一次），则采用最小堆法最合适
