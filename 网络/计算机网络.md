## 计算机网络
- **OSI七层模型**  
![](./Pics/OSI1.png)
1. 物理层：机械、电子、定时接口通信上的原始比特流传输 
2. 数据链路层：物理寻址，同时将原始比特流转变为逻辑传输线路  
`ARP`：地址解析协议  
`RARP`：逆向地址解析协议  
3. 网络层：控制子网的运行，如逻辑编址、分组传输、路由选择  
`EGP`：外部网关协议  
`RIP2`：路由信息协议第2版本  
`OSPF`：开放最短路径优先协议  
`IP/IPv6`：互联网协议/互联网协议第6版  
`ICMP/ICMPv6`：互联网控制信息协议/互联网控制信息协议第6版  
`IGMP`：互联网组管理协议  
4. 传输层：接受上一层的数据，在必要的时候把数据进行分割，并把这些数据交给网络层，且保证这些数据段有效到达对端  
`TCP`：传输控制协议  
`UDP`：用户数据报协议  
5. 会话层：不同机器上的用户之间简历及管理会话  
`SSL`：安全套接字层协议  
`TLS`：传输层安全协议  
6. 表示层：信息的语法语义以及它们的关联，如加密解密、转换翻译、压缩解压缩  
7. 应用层  
`S-HTTP`：安全超文本传输协议  
`SOCKS`：安全套接字协议  
`TFTP`：简单文件传输协议  
`DNS`：域名系统  
`SNMP`：简单网络管理协议  
- **TCP/IP**  
![](./Pics/TCP_IP1.png)
![](./Pics/TCP_IP2.png)  
- **Socket通信流程**  
![](./Pics/Socket1.png)
- **TCP三次握手**  
1. TCP Flags：  
`URG`：紧急指针标志  
`ACK`：确认序号标志  
`PSH`：push标志  
`RST`：重置连接标志  
`SYN`：同步序号，用于建立连接过程  
`FIN`：finish标志，用于释放连接  
2. TCP头部信息：源端口，目的端口，序号，确认好，校验和等  
3. 三次握手流程  
a. 在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接  
b. 第一次握手：建立连接时，客户端发送SYN包（seq=j）到服务器，并进入`SYN_SEND`状态，等待服务器确认  
c. 第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入`SYN_RECV`状态  
d. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包（ack=k+1），此包发送完毕，客户端和服务器进入`ESABLISHED`状态，完成三次握手  
![](./Pics/三次握手1.png)  
![](./Pics/三次握手2.png)  
4. 为什么需要三次握手才能建立起连接  
为了初始化`Sequence Number`的初始值  
5. 首次握手的隐患：SYN超时  
a. Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认  
b. Server不断重试直至超时，Linux默认等待63秒才断开连接  
6. 针对SYN Flood的防护措施  
a. SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。SYN攻击利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户地确认，由于源地址是不存在地，服务器需要不断地重发直至超时，这些伪造地SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪  
b. SYN队列满后，通过`tcp_syncookies`参数回发SYN Cookie  
c. 若为正常连接则Client会回发SYN Cookie，直接建立连接  
7. 建立连接后，Client出现故障怎么办  
保活机制：  
a. 向对方发送保活探测报文，如果未收到响应则继续发送  
b. 尝试次数达到保活探测数仍未收到响应则中断连接  
- **TCP四次挥手**  
1. 挥手是为了终止连接，TCP采用四次挥手来释放连接    
a. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入`FIN_WAIT_1`状态  
b. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入`CLOSE_WAIT`状态  
c. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入`LAST_ACK`状态  
d. 第四次挥手：Client收到FIN后，Client进入`TIME_WAIT`状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入`CLOSED`状态，完成四次挥手  
![](./Pics/四次挥手.png)  
2. 为什么会有`TIME_WAIT`状态  
a. 确保有足够的时间让对方收到ACK包  
b. 避免新旧连接混淆
3. 为什么需要四次挥手才能断开连接  
因为全双工，发送方和接收方都需要FIN报文和ACK报文  
4. 服务器出现大量`CLOSE_WAIT`状态的原因  
a. 对方关闭socket连接，我方忙于读或写，没有及时关闭连接  
b. 检查代码，特别是释放资源的代码；检查配置，特别是处理请求的线程配置    
- **TCP和UDP**  
1. UDP的特点：  
a. 面向非连接  
b. 不维护连接状态，支持同时向多个客户端传输相同的消息  
c. 数据包报头只有8个字节，额外开销较小  
d. 吞吐量只受限于数据生成速率、传输速率以及机器性能  
e. 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表  
f. 面向报文，不对应用程序提交的报文信息进行拆分或者合并  
2. TCP和UDP的区别  
a. 面向连接 vs 无连接  
b. 可靠性  
c. 有序性  
d. 速度  
e. 量级  
- **HTTP**  
1. 特点：  
a. 支持客户/服务器模式  
b. 简单快速  
c. 灵活  
d. 无连接  
e. 无状态   
2. HTTP请求结构  
![](./Pics/HTTP请求结构.png)   
3. HTTP响应结构  
![](./Pics/HTTP响应结构.png)
4. 请求/响应的步骤  
a. 客户端连接到Web服务器  
b. 发送HTTP请求  
c. 服务器接受请求并返回HTTP响应  
d. 释放连接TCP连接  
e. 客户端浏览器解析HTML内容  
5. 在浏览器地址栏键入URL，按下回车之后经历的流程  
a. DNS解析（浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存）  
b. TCP连接  
c. 发送HTTP请求  
d. 服务器处理请求并返回HTTP报文  
e. 浏览器解析渲染页面  
f. 连接结束  
6. HTTP状态码  
五种可能的取值：  
a. 1xx：指示信息，表示请求已接收，继续处理  
b. 2xx：成功，表示请求已被成功接收、理解、接受   
c. 3xx：重定向，要完成请求必须进行更进一步的操作  
d. 4xx：客户端错误，请求有语法错误或请求无法实现  
e. 5xx：服务器端错误，服务器未能实现合法的请求  
7. 常见的HTTP状态码  
a. 200 OK：正常返回信息  
b. 400 Bad Request：客户端请求有语法错误，不能被服务器所理解  
c. 401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用  
d. 403 Forbiddern：服务器收到请求，但是拒绝提供服务  
e. 404 Not Found：请求资源不存在，如：输入了错误的URL  
f. 500 Internal Server Error：服务器发生不可预期的错误  
g. 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常  
8. GET请求和POST请求的区别  
a. Http报文层面：GET将请求信息放在URL，POST放在报文体中  
b. 数据库层面：GET符合幂等性和安全性，POST不符合  
c. 其他层面：GET可以被缓存、被存储，而POST不行
9. Cookie简介  
a. 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端  
b. 客户端再次请求的时候，会把Cookie回发  
c. 服务器收到后，会解析Cookie，生成与客户端相对应的内容  
![](./Pics/Cookie.png)  
10. Session简介  
a. 服务器端的机制，在服务器上保存的信息  
b. 解析客户端请求并操作session id，按需保存状态信息  
![](./Pics/Session.png)  
11. Cookie和Session的区别  
a. Cookie数据存放在客户的浏览器上，Session数据放在服务器上  
b. Session相对于Cookie更安全  
c. 若考虑减轻服务器负担，应当使用Cookie  
12. DNS解析过程  
a. 以UDP报文方式给本地域名服务器发送DNS请求  
b. 若本地域名服务器查询到域名，则返回相应的IP地址  
c. 若本地域名服务器不能应答请求，则此域名服务器暂时作为DNS系统中的另一个客户，向根域名服务器发送解析请求  
d. 根域名服务器向下面所有的二级域名服务器发送解析请求，一直向下解析，直到查询到正确结果  
- **HTTP1.0/ 1.1/ 2.0**  
1. `HTTP1.0`  
a. 短链接，每次请求完毕会自动断开连接（例如100张图片，进行100轮`TCP`握手和挥手）  
b. 可以传输图像、视频等富文本信息  
c. 可以发送`get`、`post`、`put`请求  
d. 具有`http header`、状态码、缓存等基本功能  
2. `HTTP1.1`  
a. 长连接，新增`Connection: keep-alive`，请求结束后，客户端会向服务端发送`Connection: close`参数，要求服务端关闭连接（例如100张图片，进行1轮`TCP`握手和挥手）  
b. 管道机制，允许客户端一次性发送多个请求，然后服务端依次处理请求内容，`content-length`用于识别不同的请求  
c. 分块传输  
d. 新增多种请求方式，`PATCH`、`HEAD`、`OPTIONS`、`DELETE`  
3. `HTTP2.0`  
a. 长连接  
b. 多路复用  
c. 二进制传输数据，`HTTP1.1`头部信息使用文本传输，`BODY`信息使用文本或者二进制传输，为了更好的扩展性和提高性能，`HTTP2.0`将其全部统一为二进制传输  
d. 服务端主动推送  
e. 数据流，帧用于标记请求和响应之间的关系  
f. 头部压缩，客户端和服务端分别维护一张表  
- **HTTPS**
1. SSL（Security Sockets Layer，安全套接层）  
a. 为网络通信提供安全及数据完整性的一种安全协议，由第三方校验合法性    
b. 是操作系统对外的API，SSL3.0后更名为TLS  
c. 采用身份验证和数据加密保证网络通信的安全和数据的完整性  
2. 加密的方式  
a. 对称加密：加密和解密都使用同一个密钥  
b. 非对称加密：加密使用的密钥和解密使用密钥是不相同的  
c. 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆  
d. 数字签名：证明某个消息或者文件是某人发出/认同的   
3. HTTPS数据传输流程（了解）   
a. 浏览器将支持的加密算法信息发送给服务器  
b. 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器  
c. 浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器  
d. 服务器使用私钥解密信息，验证哈希，加密响应消息回发给浏览器  
e. 浏览器解密响应消息，并对消息进行验证，之后进行加密交互数据  
4. HTTPS请求流程  
a. 客户端向服务器请求连接  
b. 服务器返回证书（公钥）到客户端，（SSL证书：由第三方检验合法性，若合法则取出其中的公钥，对证书内的数字签名进行解密，并对比签名是否一致）    
c. 客户端随机选择用于对称加密的密钥  
d. 客户端用公钥对密钥进行加密，并将密文发送给服务端  
e. 服务端使用私钥对密文进行解密，得到用于对称加密的密钥  
f. 客户端和服务端通过对称密钥加密的密文通信
5. HTTP和HTTPS的区别  
a. HTTPS需要到CA申请证书，HTTP不需要  
b. HTTPS密文传输，HTTP明文传输  
c. 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口  
d. HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全  
6. HTTPS真的安全吗  
a. 浏览器默认填充`http://`，请求需要进行跳转，有被劫持的风险  
b. 可以使用HSTS（HTTP Strict Transport Security）优化（了解）  
- **拥塞控制**  
1. 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这就叫做拥塞。若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降      
![](./Pics/拥塞控制1.png)  
2. TCP有四种拥塞控制算法，假定：数据是单方向传送，而另一个方向只传送确认；接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度决定；以TCP报文段的个数为讨论问题的单位，而不是以字节为单位   
a. 发送方维护一个拥塞窗口`cwnd`，其值取决于网络的拥塞程度，并且动态变化  
b. 拥塞窗口`cwnd`的维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些；但只要网络出现拥塞，拥塞窗口就减少一些  
c. 判断出现网络拥塞的依据：没有按时收到应当到达的确认报文（即发生重传）  
d. 发送方将拥塞窗口作为发送窗口，即`swnd = cwnd`  
e. 维护一个慢开始门限`ssthresh`状态变量：当`cwnd < ssthresh`时，使用慢开始算法；当`cwnd > ssthresh`时，停止使用慢开始算法而改用拥塞避免算法；当`cwnd = ssthresh`时，既可使用慢开始算法，也可使用拥塞避免算法
3. 慢开始  
`cwnd`值为1，每轮次`cwnd`加倍
4. 拥塞避免   
a. 当拥塞窗口`cwnd`达到慢开始门限`ssthresh`时，改用拥塞避免算法，每轮次`cwnd`加1   
b. 重传计时器超时，判断网络可能出现了拥塞，则：将`ssthresh`的值更新为发生拥塞时的`cwnd`的一半；将`cwnd`的值减少为1，并重新开始执行慢开始算法  
![](./Pics/拥塞控制2.png)  
5. 注意：  
a. 慢开始是指一开始向网络注入的报文段少，并不是指拥塞窗口`cwnd`增长速度慢     
b. 拥塞避免并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞    
c. 个别报文段会在网络中丢失，并误认为网络发生了拥塞  
d. 发送方错误的启动慢开始算法，并把拥塞窗口`cwnd`又设置为最小值1，因而降低了传输效率  
6. 快重传   
a. 快重传算法可以让发送方尽早知道发生了个别报文段的丢失。快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传    
b. 要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认  
c. 即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认  
d. 发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传  
e. 对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口`cwnd`为1）。使用快重传可以使整个网络的吞吐量提高约20%  
![](./Pics/拥塞控制3.png)
7. 快恢复  
a. 发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段，于是不启动慢开始算法，而执行快恢复算法  
b. 发送方将慢开始门限`ssthresh`值和拥塞窗口`cwnd`值调整为当前窗口的一半，开始执行拥塞避免算法  
c. （了解）也有的快恢复实现是把快恢复开始时的拥塞窗口`cwnd`再增大一些，即等于新的`ssthresh + 3`。既然发送发收到3个重复的确认，就表明有3个数据报文段已经离开了网络，这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中，可见现在网络中不是堆积了报文段而是减少了3个报文段，因此可以适当把拥塞窗口扩大些  
![](./Pics/拥塞控制4.png)  
