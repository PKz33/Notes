## 重点
- **volatile**  
1. JVM提供的轻量级同步机制  
2. 保证可见性、不保证原子性、禁止指令重排  
- **JMM**  
1. JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，描述一组规则或规范，定义程序中各个变量的访问方式  
2. JMM关于同步的规定  
a. 线程解锁前，必须把共享变量的值刷新回主内存  
b. 线程加锁前，必须读取主内存的最新值到当前线程的工作内存  
c. 加锁解锁是用一把锁  
3. 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（栈空间），工作内存是每个线程的私有数据区域。Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行。首先将变量从主内存拷贝到工作内存，然后对变量进行操作，操作完成后再将变量写回主内存。不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信通过主内存完成    
4. 代码演示可见性  
```
import java.util.concurrent.TimeUnit;

class Data{
//    int number = 0;
    volatile int number = 0;
    public void add(){
        this.number = 60;
    }
}

public class Main {
    public static void main(String[] args) {
        Data data = new Data();
        new Thread(()->{
            System.out.println(Thread.currentThread().getName());
            try{
                TimeUnit.SECONDS.sleep(3);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            data.add();
            System.out.println(Thread.currentThread().getName()+"\t"+data.number);
        },"AA").start();
        while (data.number == 0){
            // 理论上，上面线程将number值修改为60后
            // main线程会终止当前循环，main线程结束
            // 实际运行情况是main线程继续循环没有结束

            // 用volatile修饰后，main线程结束，即volatile保证可见性
        }
        System.out.println(Thread.currentThread().getName());
    }
}

```  
5. 不保证原子性  
```
class Data{
    volatile int number = 0;

    public void addPlus(){
        number++;
    }
}

public class Main {
    public static void main(String[] args) {
        Data data = new Data();

        for(int i = 1;i <= 20;i++){
            new Thread(() -> {
                for (int j = 1;j <= 1000;j++){
                    data.addPlus();
                }
            },String.valueOf(i)).start();
        }


        while (Thread.activeCount() > 2){
            Thread.yield();
        }
        
        // 多次执行，number的最终值不同
        System.out.println(Thread.currentThread().getName()+"\t"+data.number);
    }
}
```
6. 保证原子性的方法  
a. 用synchronized解决  
b.   
```
import java.util.concurrent.atomic.AtomicInteger;

class Data{
    AtomicInteger atomicInteger = new AtomicInteger();

    public void addAtomic(){
        atomicInteger.getAndIncrement();
    }
}

public class Main {
    public static void main(String[] args) {
        Data data = new Data();

        for(int i = 1;i <= 20;i++){
            new Thread(() -> {
                for (int j = 1;j <= 1000;j++){
                    data.addAtomic();
                }
            },String.valueOf(i)).start();
        }


        while (Thread.activeCount() > 2){
            Thread.yield();
        }

        System.out.println(Thread.currentThread().getName()+"\t"+data.atomicInteger);
    }
}
```  
7. 计算机在执行程序时，为了提高性能，编译器和处理器通常会对指令做重排（编译器优化的重排、指令并行的重排、内存系统的重排）。处理器在进行重排时必须考虑指令之间的数据依赖性。多线程环境中线程交替执行，由于编译器优化重排的存在，多个线程中使用的变量能否保证一致性是无法确定的，结果无法预测    
8. 内存屏障又称内存栅栏，是一个CPU指令，有两个作用：一是保证特定操作的执行顺序，二是保证某些变量的内存可见性。编译器和处理器都能执行指令重排优化，通过插入内存屏障，禁止在内存屏障前后的指令执行重排优化，内存屏障的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到数据的最新版本。对volatile修饰的变量进行写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新回主内存；进行读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量值  
9. 单例模式中应用volatile  
```
public class Singleton{
    private static volatile Singleton instance = null;
    private Singleton(){
    }
    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    // 1.分配对象内存空间
                    // 2.初始化对象
                    // 3.设置instance指向分配的内存地址
                    // 2和3不存在数据依赖关系
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```  
- **CAS**  
1. 源码  
```
public final boolean compareAndSet(int expect, int update){
    // valueOffset，表示变量值在内存中的偏移地址
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}

public final int getAndIncrement(){
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
```  
2. 
```
import java.util.concurrent.atomic.AtomicInteger;

public class Main {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(5);
        System.out.println(atomicInteger.compareAndSet(5,2021)+"\t"+atomicInteger.get());
        System.out.println(atomicInteger.compareAndSet(5,1024)+"\t"+atomicInteger.get());
    }
}

```  
3. Unsafe类事CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问。Unsafe类在sun.misc包中，其内部方法可以像C语言的指针一样直接操作内存，CAS操作的执行依赖于Unsafe类的方法。Unsafe类中的所有方法都是native修饰的，即Unsafe类中的方法都直接调用操作系统底层资源执行相应任务  
4. CAS全称是Compare-And-Swap，是一条CPU并发原语。CAS依赖于硬件，实现原子操作，是一种系统原语。原语属于操作系统用语范畴，由若干条指令组成，用于完成某个功能。原语的执行是连续的，在执行过程中不允许被中断，即CAS是一条CPU原子指令，不会造成数据不一致问题  
5. CAS缺点：自旋，循环时间长开销大；只能保证一个共享变量的原子操作；ABA问题  
```
// Unsafe.getAndAddInt
public final int getAndAddInt(Object var1, long var2, int var4){
    int var5;
    do{
        var5 = this.getIntVolatile(var1, var2);
    }while(!this.compareAndSwapInt(var1, var2, var5, var5+var4));
    return var5;
}
```  
6. 
```
import java.util.concurrent.atomic.AtomicReference;

class User{
    String name;
    int age;
    public User(String name, int age){
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return this.name+"\t"+this.age;
    }
}

public class Main {
    public static void main(String[] args) {
        AtomicReference<User> atomicReference = new AtomicReference<>();
        User z3 = new User("z3", 22);
        User l4 = new User("l4", 23);
        atomicReference.set(z3);
        System.out.println(atomicReference.compareAndSet(z3,l4)+"\t"+atomicReference.get().toString());
    }
}
```  
7. ABA问题  
```
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class Main {
    static AtomicReference<Integer> ar = new AtomicReference<>(100);
    public static void main(String[] args) {
        new Thread(()->{
            ar.compareAndSet(100,101);
            ar.compareAndSet(101,100);
        },"t1").start();
        new Thread(()->{
            try{TimeUnit.SECONDS.sleep(1);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            System.out.println(ar.compareAndSet(100,2021)+"\t"+ar.get());
        },"t2").start();
    }
}
```  
8. ABA问题解决  
```
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicStampedReference;

public class Main {
    // static AtomicReference<Integer> ar = new AtomicReference<>(100);
    static AtomicStampedReference<Integer> ar = new AtomicStampedReference<>(100,1);
    public static void main(String[] args) {
        int stamp = ar.getStamp();
        new Thread(()->{
            ar.compareAndSet(100,101,stamp,stamp+1);
            ar.compareAndSet(101,100,ar.getStamp(),ar.getStamp()+1);
        },"t1").start();
        new Thread(()->{
            try{TimeUnit.SECONDS.sleep(1);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            System.out.println(ar.compareAndSet(100,2021,stamp,stamp+1)+"\t"+ar.getReference());
        },"t2").start();
    }
}
```  
9. 集合类不安全的问题  
```
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class Main {
    // java.util.ConcurrentModificationException
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        for(int i = 1;i <= 30;i++){
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
```  
10. 集合不安全问题的解决方法  
```
// 使用Vector
List<String> list = new Vector<>();

// 使用Collections工具类
List<String> list = Collections.synchronizedList(new ArrayList<>());
// Collections.synchronizedSet()
// Collections.synchronizedMap()

// 使用CopyOnWriteArrayList
List<String> list = new CopyOnWriteArrayList<>();
```  
11. CopyOnWrite容器即写时复制的容器，往容器添加元素的时候，并不直接往当前容器Object[]添加，而是先将当前容器Object[]进行copy，复制出一个新的容器Object[] newElements，让后向新容器Object[] newElements添加元素，添加完元素之后，再将原容器的引用指向新容器setArray(newElements)。这样就可以进行并发的读，而不需要加锁，这是一种读写分离的思想，读和写不同的容器  
- **公平锁和非公平锁**  
1. ReentrantLock默认是非公平锁
```
public ReentrantLock(){
    sync = new NonfairSync();
}

public ReentrantLock(boolean fair){
    sync = fair ? new FairSync() : new NonfairSync();
}
```  
2. Synchronized是一种非公平锁  
- **可重入锁**  
1. ReentrantLock/Synchronized是可重入锁（也叫递归锁），线程可以进入它已经获取的锁所同步的内部代码块  
```
class Cls{
    public synchronized void m1(){
        System.out.println(Thread.currentThread().getId());
        m2();
    }

    public synchronized void m2(){
        System.out.println(Thread.currentThread().getId());
    }
}

public class Main {

    public static void main(String[] args){
        Cls cls = new Cls();
        new Thread(()->{
            cls.m1();
        },"t1").start();
        new Thread(()->{
            cls.m1();
        },"t2").start();
    }
}



import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Cls implements Runnable{
    Lock lock = new ReentrantLock();
    @Override
    public void run(){
        get();
    }

    public void get(){
        lock.lock();
        try{
            System.out.println(Thread.currentThread().getName());
            set();
        }finally {
            lock.unlock();
        }
    }

    public void set(){
        lock.lock();
        try{
            System.out.println(Thread.currentThread().getName());
        }finally {
            lock.unlock();
        }
    }
}

public class Main {

    public static void main(String[] args){
        Cls cls = new Cls();
        Thread t1 = new Thread(cls,"t3");
        Thread t2 = new Thread(cls,"t4");
        t1.start();
        t2.start();
    }
}

```
- **自旋锁**  
1. 指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，可以减少上下文切换的消耗，但循环会消耗CPU资源  
2. 自定义实现  
```
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class Main {

    AtomicReference<Thread> ar = new AtomicReference<>();

    public void mLock(){
        Thread t = Thread.currentThread();
        System.out.println(Thread.currentThread().getName()+"\t lock");
        while (!ar.compareAndSet(null,t)){
            System.out.println(Thread.currentThread().getName()+"\t loop");
        }
    }

    public void mUnlock(){
        Thread t = Thread.currentThread();
        ar.compareAndSet(t,null);
        System.out.println(Thread.currentThread().getName()+"\t unlock");
    }

    public static void main(String[] args){
            Main lock = new Main();

            new Thread(()->{
                lock.mLock();
                try{
                    TimeUnit.SECONDS.sleep(2);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
                lock.mUnlock();
            },"t1").start();

            try{
                TimeUnit.SECONDS.sleep(1);
            }catch (InterruptedException e){
                e.printStackTrace();
            }

            new Thread(()->{
                lock.mLock();
                lock.mUnlock();
            },"t2").start();
    }
}
```  
- **独占锁和共享锁**  
1. ReentrantLock和Synchronized都是独占锁；ReentrantReadWriteLock的读锁是共享锁，写锁是独占锁  
2. 代码演示  
```
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

class MCache{
    private volatile Map<String, Object> map = new HashMap<>();
    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void put(String key, Object value){
        rwLock.writeLock().lock();
        try{
            System.out.println(Thread.currentThread().getName()+"\t 正在写入："+key);
            TimeUnit.MILLISECONDS.sleep(300);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName()+"\t 写入完成");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            rwLock.writeLock().unlock();
        }
    }

    public void get(String key){
        rwLock.readLock().lock();
        try{
            System.out.println(Thread.currentThread().getName()+"\t 正在读取：");
            TimeUnit.MILLISECONDS.sleep(300);
            Object res = map.get(key);
            System.out.println(Thread.currentThread().getName()+"\t 读取完成："+res);
        }catch (InterruptedException e){
            e.printStackTrace();
        }finally {
            rwLock.readLock().unlock();
        }
    }
}

public class Main {

    public static void main(String[] args){
        MCache mCache = new MCache();
        for (int i = 1; i <= 5; i++) {
            final int tInt = i;
            new Thread(()->{
                mCache.put(tInt+"", tInt+"");
            }, String.valueOf(i)).start();
        }
        for (int i = 1; i <= 5; i++) {
            final int tInt = i;
            new Thread(()->{
               mCache.get(tInt+"");
            }, String.valueOf(i)).start();
        }
    }
}
```  
- **CountDownLatch**  
1. 
```
import java.util.concurrent.CountDownLatch;

public class Main {
    public static void main(String[] args) throws Exception{
        CountDownLatch cdl = new CountDownLatch(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"\t 离开图书馆");
                cdl.countDown();
            }, String.valueOf(i)).start();
        }
        cdl.await();
        System.out.println(Thread.currentThread().getName()+"\t 闭馆");
    }
}
```  
2.  
```
import java.util.concurrent.CountDownLatch;

public enum CountryEnum {
    ONE(1,"齐"),TWO(2,"楚"),THREE(3,"燕"),FOUR(4,"赵"),FIVE(5,"魏"),SIX(6,"韩");

    private Integer retCode;
    private String retMsg;

    public Integer getRetCode() {
        return retCode;
    }

    public void setRetCode(Integer retCode) {
        this.retCode = retCode;
    }

    public String getRetMsg() {
        return retMsg;
    }

    public void setRetMsg(String retMsg) {
        this.retMsg = retMsg;
    }

    CountryEnum(Integer retCode, String retMsg){
        this.retCode = retCode;
        this.retMsg = retMsg;
    }

    public static CountryEnum forEach_CountryEnum(int index){
        CountryEnum[] mArr = CountryEnum.values();
        for(CountryEnum ele : mArr){
            if(index == ele.getRetCode()){
                return ele;
            }
        }
        return null;
    }

    public static void main(String[] args) throws Exception{
        CountDownLatch cdl = new CountDownLatch(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"\t 国灭");
                cdl.countDown();
            }, CountryEnum.forEach_CountryEnum(i).getRetMsg()).start();
        }
        cdl.await();
        System.out.println(Thread.currentThread().getName()+"\t 秦灭六国");
    }
}
```
3. CountDownLatch主要有两个方法，线程调用await方法时，会被阻塞。线程调用countDown方法会将计数器减1，当计数器的值变为零时，因调用await方法被阻塞的线程会被唤醒  
- **CycleBarrier**  
1. 
```
import java.util.concurrent.CyclicBarrier;

public class Main {

    public static void main(String[] args) throws Exception{
        CyclicBarrier cb = new CyclicBarrier(7,()->{
            System.out.println("召唤神龙");
        });
        for (int i = 1; i <= 7; i++) {
            final int tInt = i;
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"\t 收集第"+tInt+"颗龙珠");
                try{
                    cb.await();
                }catch (Exception e){
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}
```  
- **Semaphore**  
```
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class Main {

    public static void main(String[] args){
        Semaphore sp = new Semaphore(3);
        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                try {
                    sp.acquire();
                    System.out.println(Thread.currentThread().getName()+"\t 抢到车位");
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println(Thread.currentThread().getName()+"\t 离开车位");
                }catch (Exception e){
                    e.printStackTrace();
                }finally {
                    sp.release();
                }
            }, String.valueOf(i)).start();
        }
    }
}
```  
- **阻塞队列**  
1. ArrayBlockingQueue，由数组结构组成的有界阻塞队列；LinkedBlockingQueue，由链表结构组成的有界（大小默认值为Integer.MAX_VALUE）阻塞队列；PriorityBlockingQueue，支持优先级排序的无界阻塞队列；DelayQueue，使用优先级队列实现的延迟无界阻塞队列；SynchronousQueue，不存储元素的阻塞队列，即单个元素的队列；LinkedTransferQueue，由链表结构组成的无界阻塞队列；LinkedBlockingDeque，由链表结构组成的双向阻塞队列  
2. 
```
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class Main {

    public static void main(String[] args){
        BlockingQueue<String> bq = new ArrayBlockingQueue<>(3);
        System.out.println(bq.add("a"));
        System.out.println(bq.add("b"));
        System.out.println(bq.add("c"));

        // java.lang.IllegalStateException: Queue full
        // System.out.println(bq.add("x"));
        
        System.out.println(bq.element());

        System.out.println(bq.remove());
        System.out.println(bq.remove());
        System.out.println(bq.remove());
        
        System.out.println(bq.peek());

        System.out.println(bq.poll());
        System.out.println(bq.poll());
        System.out.println(bq.poll());
        
        System.out.println(bq.offer("a", 2L, TimeUnit.SECONDS));
        System.out.println(bq.offer("a", 2L, TimeUnit.SECONDS));
        System.out.println(bq.offer("a", 2L, TimeUnit.SECONDS));
        System.out.println(bq.offer("a", 2L, TimeUnit.SECONDS));
    }
}
```  
3.  
```
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class Main {

    public static void main(String[] args) throws Exception{
        BlockingQueue<String> bq = new ArrayBlockingQueue<>(3);
        bq.put("a");
        bq.put("a");
        bq.put("a");
        bq.take();
        bq.take();
        bq.take();
        // 阻塞直到队列可用
        bq.take();
    }
}
```  
4. 
```
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

public class Main {

    public static void main(String[] args) throws Exception{
        BlockingQueue<String> bq = new SynchronousQueue<>();
        new Thread(()->{
            try{
                System.out.println(Thread.currentThread().getName()+"\t put 1");
                bq.put("1");
                System.out.println(Thread.currentThread().getName()+"\t put 2");
                bq.put("2");
                System.out.println(Thread.currentThread().getName()+"\t put 3");
                bq.put("3");
            }catch (Exception e){
                e.printStackTrace();
            }
        }, "t1").start();

        new Thread(()->{
            try{
                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName()+"\t take "+bq.take());
                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName()+"\t take "+bq.take());
                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName()+"\t take "+bq.take());
            }catch (Exception e){
                e.printStackTrace();
            }
        }, "t2").start();
    }
}
```
- **生产者消费者**  
1.  
```
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ShareData{
    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition cond = lock.newCondition();

    public void incre() throws Exception{
        lock.lock();
        try{
            while (number != 0){
                cond.await();
            }
            number++;
            System.out.println(Thread.currentThread().getName()+"\t"+number);
            cond.signalAll();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void decre() throws Exception{
        lock.lock();
        try{
            while (number == 0){
                cond.await();
            }
            number--;
            System.out.println(Thread.currentThread().getName()+"\t"+number);
            cond.signalAll();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}

public class Main {

    public static void main(String[] args){
        ShareData sd = new ShareData();
        new Thread(()->{
            for (int i = 1; i <= 5; i++) {
                try{
                    sd.incre();
                }catch (Exception e){
                    e.printStackTrace();
                }
            }
        }, "t1").start();
        new Thread(()->{
            for (int i = 1; i <= 5; i++) {
                try{
                    sd.decre();
                }catch (Exception e){
                    e.printStackTrace();
                }
            }
        }, "t2").start();
    }
}
```  
2. synchronized是关键字属于JVM层面，Lock是具体类属于API层面；synchronized不需要手动释放锁，ReentrantLock需要手动释放锁；synchronized不可中断，除非抛出异常或正常运行完成，ReentrantLock可中断，通过设置超时方法tryLock(Long timeout, TimeUnit unit)或者lockInterruptibly调用interrupt()方法来中断；synchronized是非公平锁，ReentrantLock默认是非公平锁，可以通过构造方法设置为公平锁；ReentrantLock可以分组唤醒线程，synchronized只能随机唤醒一个线程或者唤醒全部线程  
3. 线程同步  
```
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ShareData{
    private int number = 1;
    private Lock lock = new ReentrantLock();
    private Condition c1 = lock.newCondition();
    private Condition c2 = lock.newCondition();
    private Condition c3 = lock.newCondition();

    public void print5(){
        lock.lock();
        try{
            while (number != 1){
                c1.await();
            }
            for (int i = 1; i <= 5; i++) {
                System.out.println(Thread.currentThread().getName()+"\t"+i);
            }
            number = 2;
            c2.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void print10(){
        lock.lock();
        try{
            while (number != 2){
                c2.await();
            }
            for (int i = 1; i <= 10; i++) {
                System.out.println(Thread.currentThread().getName()+"\t"+i);
            }
            number = 3;
            c3.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void print15(){
        lock.lock();
        try{
            while (number != 3){
                c3.await();
            }
            for (int i = 1; i <= 15; i++) {
                System.out.println(Thread.currentThread().getName()+"\t"+i);
            }
            number = 1;
            c1.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

}

public class Main {

    public static void main(String[] args){
        ShareData sd = new ShareData();
        new Thread(()->{
            for (int i = 1; i <= 10; i++) {
                sd.print5();
            }
        }, "t1").start();
        new Thread(()->{
            for (int i = 1; i <= 10; i++) {
                sd.print10();
            }
        }, "t2").start();
        new Thread(()->{
            for (int i = 1; i <= 10; i++) {
                sd.print15();
            }
        }, "t3").start();
    }
}
```  
4.  
```
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ShareData{
    private volatile boolean FLAG = true;
    private AtomicInteger ai = new AtomicInteger();

    BlockingQueue<String> bq = null;
    public ShareData(BlockingQueue<String> bq){
        this.bq = bq;
        System.out.println(bq.getClass().getName());
    }

    public void prod() throws Exception{
        String data = null;
        boolean retVal;
        while (FLAG){
            data = ai.incrementAndGet()+"";
            retVal = bq.offer(data, 2L, TimeUnit.SECONDS);
            if (retVal){
                System.out.println(Thread.currentThread().getName()+"\t插入"+data+"成功");
            }else {
                System.out.println(Thread.currentThread().getName()+"\t插入"+data+"失败");
            }
            TimeUnit.SECONDS.sleep(1);
        }
        System.out.println(Thread.currentThread().getName()+"\t停止生产");
    }

    public void consum() throws Exception{
        String res = null;
        while (FLAG){
            res = bq.poll(2L, TimeUnit.SECONDS);
            if (null == res || res.equalsIgnoreCase("")){
                FLAG = false;
                System.out.println(Thread.currentThread().getName()+"\t生产不足，停止消费");
                return;
            }
            System.out.println(Thread.currentThread().getName()+"\t消费"+res+"成功");
        }
    }

    public void stop() throws Exception{
        this.FLAG = false;
    }

}

public class Main {

    public static void main(String[] args) throws Exception{
        ShareData sd = new ShareData(new ArrayBlockingQueue<>(10));
        new Thread(()->{
            System.out.println(Thread.currentThread().getName()+"\t开始生产");
            try{
                sd.prod();
            }catch (Exception e){
                e.printStackTrace();
            }
        }, "prod").start();
        new Thread(()->{
            System.out.println(Thread.currentThread().getName()+"\t开始消费");
            try{
                sd.consum();
            }catch (Exception e){
                e.printStackTrace();
            }
        }, "consum").start();

        try{TimeUnit.SECONDS.sleep(3);}catch (Exception e){
            e.printStackTrace();
        }
        System.out.println("停止生产消费");
        sd.stop();
    }
}
```  
- **Callable**  
1.  
```
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;

class mThread1 implements Runnable{
    @Override
    public void run(){}
}

class mThread2 implements Callable<Integer>{
    @Override
    public Integer call() throws Exception{
        System.out.println("Callable");
        try{
            TimeUnit.SECONDS.sleep(2);
        }catch (Exception e){
            e.printStackTrace();
        }
        return 123;
    }
}

public class Main {

    public static void main(String[] args) throws Exception{
        FutureTask<Integer> ft = new FutureTask<>(new mThread2());
        Thread t1 = new Thread(ft, "t1");
        t1.start();
        int var1 = 100;
        while (!ft.isDone()){}
        int var2 = ft.get();
        System.out.println((var1+var2));
    }
}
```
