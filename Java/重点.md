## 重点
- **volatile**  
1. JVM提供的轻量级同步机制  
2. 保证可见性、不保证原子性、禁止指令重排  
- **JMM**  
1. JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，描述一组规则或规范，定义程序中各个变量的访问方式  
2. JMM关于同步的规定  
a. 线程解锁前，必须把共享变量的值刷新回主内存  
b. 线程加锁前，必须读取主内存的最新值到当前线程的工作内存  
c. 加锁解锁是用一把锁  
3. 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（栈空间），工作内存是每个线程的私有数据区域。Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行。首先将变量从主内存拷贝到工作内存，然后对变量进行操作，操作完成后再将变量写回主内存。不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信通过主内存完成    
4. 代码演示可见性  
```
import java.util.concurrent.TimeUnit;

class Data{
//    int number = 0;
    volatile int number = 0;
    public void add(){
        this.number = 60;
    }
}

public class Main {
    public static void main(String[] args) {
        Data data = new Data();
        new Thread(()->{
            System.out.println(Thread.currentThread().getName());
            try{
                TimeUnit.SECONDS.sleep(3);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            data.add();
            System.out.println(Thread.currentThread().getName()+"\t"+data.number);
        },"AA").start();
        while (data.number == 0){
            // 理论上，上面线程将number值修改为60后
            // main线程会终止当前循环，main线程结束
            // 实际运行情况是main线程继续循环没有结束

            // 用volatile修饰后，main线程结束，即volatile保证可见性
        }
        System.out.println(Thread.currentThread().getName());
    }
}

```  
5. 不保证原子性  
```
class Data{
    volatile int number = 0;

    public void addPlus(){
        number++;
    }
}

public class Main {
    public static void main(String[] args) {
        Data data = new Data();

        for(int i = 1;i <= 20;i++){
            new Thread(() -> {
                for (int j = 1;j <= 1000;j++){
                    data.addPlus();
                }
            },String.valueOf(i)).start();
        }


        while (Thread.activeCount() > 2){
            Thread.yield();
        }
        
        // 多次执行，number的最终值不同
        System.out.println(Thread.currentThread().getName()+"\t"+data.number);
    }
}
```
6. 保证原子性的方法  
a. 用synchronized解决  
b.   
```
import java.util.concurrent.atomic.AtomicInteger;

class Data{
    AtomicInteger atomicInteger = new AtomicInteger();

    public void addAtomic(){
        atomicInteger.getAndIncrement();
    }
}

public class Main {
    public static void main(String[] args) {
        Data data = new Data();

        for(int i = 1;i <= 20;i++){
            new Thread(() -> {
                for (int j = 1;j <= 1000;j++){
                    data.addAtomic();
                }
            },String.valueOf(i)).start();
        }


        while (Thread.activeCount() > 2){
            Thread.yield();
        }

        System.out.println(Thread.currentThread().getName()+"\t"+data.atomicInteger);
    }
}
```  
7. 计算机在执行程序时，为了提高性能，编译器和处理器通常会对指令做重排（编译器优化的重排、指令并行的重排、内存系统的重排）。处理器在进行重排时必须考虑指令之间的数据依赖性。多线程环境中线程交替执行，由于编译器优化重排的存在，多个线程中使用的变量能否保证一致性是无法确定的，结果无法预测    
8. 内存屏障又称内存栅栏，是一个CPU指令，有两个作用：一是保证特定操作的执行顺序，二是保证某些变量的内存可见性。编译器和处理器都能执行指令重排优化，通过插入内存屏障，禁止在内存屏障前后的指令执行重排优化，内存屏障的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到数据的最新版本。对volatile修饰的变量进行写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新回主内存；进行读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量值  
9. 单例模式中应用volatile  
```
public class Singleton{
    private static volatile Singleton instance = null;
    private Singleton(){
    }
    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    // 1.分配对象内存空间
                    // 2.初始化对象
                    // 3.设置instance指向分配的内存地址
                    // 2和3不存在数据依赖关系
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```  
- **CAS**  
1. 源码  
```
public final boolean compareAndSet(int expect, int update){
    // valueOffset，表示变量值在内存中的偏移地址
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}

public final int getAndIncrement(){
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
```  
2. 
```
import java.util.concurrent.atomic.AtomicInteger;

public class Main {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(5);
        System.out.println(atomicInteger.compareAndSet(5,2021)+"\t"+atomicInteger.get());
        System.out.println(atomicInteger.compareAndSet(5,1024)+"\t"+atomicInteger.get());
    }
}

```  
3. Unsafe类事CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问。Unsafe类在sun.misc包中，其内部方法可以像C语言的指针一样直接操作内存，CAS操作的执行依赖于Unsafe类的方法。Unsafe类中的所有方法都是native修饰的，即Unsafe类中的方法都直接调用操作系统底层资源执行相应任务  
4. CAS全称是Compare-And-Swap，是一条CPU并发原语。CAS依赖于硬件，实现原子操作，是一种系统原语。原语属于操作系统用语范畴，由若干条指令组成，用于完成某个功能。原语的执行是连续的，在执行过程中不允许被中断，即CAS是一条CPU原子指令，不会造成数据不一致问题  
5. CAS缺点：自旋，循环时间长开销大；只能保证一个共享变量的原子操作；ABA问题  
```
// Unsafe.getAndAddInt
public final int getAndAddInt(Object var1, long var2, int var4){
    int var5;
    do{
        var5 = this.getIntVolatile(var1, var2);
    }while(!this.compareAndSwapInt(var1, var2, var5, var5+var4));
    return var5;
}
```  
6. 
```
import java.util.concurrent.atomic.AtomicReference;

class User{
    String name;
    int age;
    public User(String name, int age){
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return this.name+"\t"+this.age;
    }
}

public class Main {
    public static void main(String[] args) {
        AtomicReference<User> atomicReference = new AtomicReference<>();
        User z3 = new User("z3", 22);
        User l4 = new User("l4", 23);
        atomicReference.set(z3);
        System.out.println(atomicReference.compareAndSet(z3,l4)+"\t"+atomicReference.get().toString());
    }
}
```  
7. ABA问题  
```
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class Main {
    static AtomicReference<Integer> ar = new AtomicReference<>(100);
    public static void main(String[] args) {
        new Thread(()->{
            ar.compareAndSet(100,101);
            ar.compareAndSet(101,100);
        },"t1").start();
        new Thread(()->{
            try{TimeUnit.SECONDS.sleep(1);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            System.out.println(ar.compareAndSet(100,2021)+"\t"+ar.get());
        },"t2").start();
    }
}
```  
8. ABA问题解决  
```
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicStampedReference;

public class Main {
    // static AtomicReference<Integer> ar = new AtomicReference<>(100);
    static AtomicStampedReference<Integer> ar = new AtomicStampedReference<>(100,1);
    public static void main(String[] args) {
        int stamp = ar.getStamp();
        new Thread(()->{
            ar.compareAndSet(100,101,stamp,stamp+1);
            ar.compareAndSet(101,100,ar.getStamp(),ar.getStamp()+1);
        },"t1").start();
        new Thread(()->{
            try{TimeUnit.SECONDS.sleep(1);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            System.out.println(ar.compareAndSet(100,2021,stamp,stamp+1)+"\t"+ar.getReference());
        },"t2").start();
    }
}
```  
9. 集合类不安全的问题  
```
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class Main {
    // java.util.ConcurrentModificationException
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        for(int i = 1;i <= 30;i++){
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
```  
10. 集合不安全问题的解决方法  
```
// 使用Vector
List<String> list = new Vector<>();

// 使用Collections工具类
List<String> list = Collections.synchronizedList(new ArrayList<>());
// Collections.synchronizedSet()
// Collections.synchronizedMap()

// 使用CopyOnWriteArrayList
List<String> list = new CopyOnWriteArrayList<>();
```  
11. CopyOnWrite容器即写时复制的容器，往容器添加元素的时候，并不直接往当前容器Object[]添加，而是先将当前容器Object[]进行copy，复制出一个新的容器Object[] newElements，让后向新容器Object[] newElements添加元素，添加完元素之后，再将原容器的引用指向新容器setArray(newElements)。这样就可以进行并发的读，而不需要加锁，这是一种读写分离的思想，读和写不同的容器  
- **公平锁和非公平锁**  
1. ReentrantLock默认是非公平锁
```
public ReentrantLock(){
    sync = new NonfairSync();
}

public ReentrantLock(boolean fair){
    sync = fair ? new FairSync() : new NonfairSync();
}
```  
2. Synchronized是一种非公平锁  
- **可重入锁**  
1. ReentrantLock/Synchronized是可重入锁（也叫递归锁），线程可以进入它已经获取的锁所同步的内部代码块  
```
class Cls{
    public synchronized void m1(){
        System.out.println(Thread.currentThread().getId());
        m2();
    }

    public synchronized void m2(){
        System.out.println(Thread.currentThread().getId());
    }
}

public class Main {

    public static void main(String[] args){
        Cls cls = new Cls();
        new Thread(()->{
            cls.m1();
        },"t1").start();
        new Thread(()->{
            cls.m1();
        },"t2").start();
    }
}



import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Cls implements Runnable{
    Lock lock = new ReentrantLock();
    @Override
    public void run(){
        get();
    }

    public void get(){
        lock.lock();
        try{
            System.out.println(Thread.currentThread().getName());
            set();
        }finally {
            lock.unlock();
        }
    }

    public void set(){
        lock.lock();
        try{
            System.out.println(Thread.currentThread().getName());
        }finally {
            lock.unlock();
        }
    }
}

public class Main {

    public static void main(String[] args){
        Cls cls = new Cls();
        Thread t1 = new Thread(cls,"t3");
        Thread t2 = new Thread(cls,"t4");
        t1.start();
        t2.start();
    }
}

```
- **自旋锁**  
1. 指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，可以减少上下文切换的消耗，但循环会消耗CPU资源  
2. 自定义实现  
```
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class Main {

    AtomicReference<Thread> ar = new AtomicReference<>();

    public void mLock(){
        Thread t = Thread.currentThread();
        System.out.println(Thread.currentThread().getName()+"\t lock");
        while (!ar.compareAndSet(null,t)){
            System.out.println(Thread.currentThread().getName()+"\t loop");
        }
    }

    public void mUnlock(){
        Thread t = Thread.currentThread();
        ar.compareAndSet(t,null);
        System.out.println(Thread.currentThread().getName()+"\t unlock");
    }

    public static void main(String[] args){
            Main lock = new Main();

            new Thread(()->{
                lock.mLock();
                try{
                    TimeUnit.SECONDS.sleep(2);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
                lock.mUnlock();
            },"t1").start();

            try{
                TimeUnit.SECONDS.sleep(1);
            }catch (InterruptedException e){
                e.printStackTrace();
            }

            new Thread(()->{
                lock.mLock();
                lock.mUnlock();
            },"t2").start();
    }
}
```  
- **独占锁和共享锁**  
1. ReentrantLock和Synchronized都是独占锁；ReentrantReadWriteLock的读锁是共享锁，写锁是独占锁  
2. 代码演示  
```
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

class MCache{
    private volatile Map<String, Object> map = new HashMap<>();
    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void put(String key, Object value){
        rwLock.writeLock().lock();
        try{
            System.out.println(Thread.currentThread().getName()+"\t 正在写入："+key);
            TimeUnit.MILLISECONDS.sleep(300);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName()+"\t 写入完成");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            rwLock.writeLock().unlock();
        }
    }

    public void get(String key){
        rwLock.readLock().lock();
        try{
            System.out.println(Thread.currentThread().getName()+"\t 正在读取：");
            TimeUnit.MILLISECONDS.sleep(300);
            Object res = map.get(key);
            System.out.println(Thread.currentThread().getName()+"\t 读取完成："+res);
        }catch (InterruptedException e){
            e.printStackTrace();
        }finally {
            rwLock.readLock().unlock();
        }
    }
}

public class Main {

    public static void main(String[] args){
        MCache mCache = new MCache();
        for (int i = 1; i <= 5; i++) {
            final int tInt = i;
            new Thread(()->{
                mCache.put(tInt+"", tInt+"");
            }, String.valueOf(i)).start();
        }
        for (int i = 1; i <= 5; i++) {
            final int tInt = i;
            new Thread(()->{
               mCache.get(tInt+"");
            }, String.valueOf(i)).start();
        }
    }
}
```  
- **CountDownLatch**  
1. 
```
import java.util.concurrent.CountDownLatch;

public class Main {
    public static void main(String[] args) throws Exception{
        CountDownLatch cdl = new CountDownLatch(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"\t 离开图书馆");
                cdl.countDown();
            }, String.valueOf(i)).start();
        }
        cdl.await();
        System.out.println(Thread.currentThread().getName()+"\t 闭馆");
    }
}
```  
2.  
```
import java.util.concurrent.CountDownLatch;

public enum CountryEnum {
    ONE(1,"齐"),TWO(2,"楚"),THREE(3,"燕"),FOUR(4,"赵"),FIVE(5,"魏"),SIX(6,"韩");

    private Integer retCode;
    private String retMsg;

    public Integer getRetCode() {
        return retCode;
    }

    public void setRetCode(Integer retCode) {
        this.retCode = retCode;
    }

    public String getRetMsg() {
        return retMsg;
    }

    public void setRetMsg(String retMsg) {
        this.retMsg = retMsg;
    }

    CountryEnum(Integer retCode, String retMsg){
        this.retCode = retCode;
        this.retMsg = retMsg;
    }

    public static CountryEnum forEach_CountryEnum(int index){
        CountryEnum[] mArr = CountryEnum.values();
        for(CountryEnum ele : mArr){
            if(index == ele.getRetCode()){
                return ele;
            }
        }
        return null;
    }

    public static void main(String[] args) throws Exception{
        CountDownLatch cdl = new CountDownLatch(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"\t 国灭");
                cdl.countDown();
            }, CountryEnum.forEach_CountryEnum(i).getRetMsg()).start();
        }
        cdl.await();
        System.out.println(Thread.currentThread().getName()+"\t 秦灭六国");
    }
}
```
3. CountDownLatch主要有两个方法，线程调用await方法时，会被阻塞。线程调用countDown方法会将计数器减1，当计数器的值变为零时，因调用await方法被阻塞的线程会被唤醒  
- **CycleBarrier**  
1. 
```
import java.util.concurrent.CyclicBarrier;

public class Main {

    public static void main(String[] args) throws Exception{
        CyclicBarrier cb = new CyclicBarrier(7,()->{
            System.out.println("召唤神龙");
        });
        for (int i = 1; i <= 7; i++) {
            final int tInt = i;
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"\t 收集第"+tInt+"颗龙珠");
                try{
                    cb.await();
                }catch (Exception e){
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}
```  
- **Semaphore**  
```
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class Main {

    public static void main(String[] args){
        Semaphore sp = new Semaphore(3);
        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                try {
                    sp.acquire();
                    System.out.println(Thread.currentThread().getName()+"\t 抢到车位");
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println(Thread.currentThread().getName()+"\t 离开车位");
                }catch (Exception e){
                    e.printStackTrace();
                }finally {
                    sp.release();
                }
            }, String.valueOf(i)).start();
        }
    }
}
```  
- **阻塞队列**  
1. ArrayBlockingQueue，由数组结构组成的有界阻塞队列；LinkedBlockingQueue，由链表结构组成的有界（大小默认值为Integer.MAX_VALUE）阻塞队列；PriorityBlockingQueue，支持优先级排序的无界阻塞队列；DelayQueue，使用优先级队列实现的延迟无界阻塞队列；SynchronousQueue，不存储元素的阻塞队列，即单个元素的队列；LinkedTransferQueue，由链表结构组成的无界阻塞队列；LinkedBlockingDeque，由链表结构组成的双向阻塞队列  
2. 
```
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class Main {

    public static void main(String[] args){
        BlockingQueue<String> bq = new ArrayBlockingQueue<>(3);
        System.out.println(bq.add("a"));
        System.out.println(bq.add("b"));
        System.out.println(bq.add("c"));

        // java.lang.IllegalStateException: Queue full
        // System.out.println(bq.add("x"));
        
        System.out.println(bq.element());

        System.out.println(bq.remove());
        System.out.println(bq.remove());
        System.out.println(bq.remove());
        
        System.out.println(bq.peek());

        System.out.println(bq.poll());
        System.out.println(bq.poll());
        System.out.println(bq.poll());
        
        System.out.println(bq.offer("a", 2L, TimeUnit.SECONDS));
        System.out.println(bq.offer("a", 2L, TimeUnit.SECONDS));
        System.out.println(bq.offer("a", 2L, TimeUnit.SECONDS));
        System.out.println(bq.offer("a", 2L, TimeUnit.SECONDS));
    }
}
```  
3.  
```
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class Main {

    public static void main(String[] args) throws Exception{
        BlockingQueue<String> bq = new ArrayBlockingQueue<>(3);
        bq.put("a");
        bq.put("a");
        bq.put("a");
        bq.take();
        bq.take();
        bq.take();
        // 阻塞直到队列可用
        bq.take();
    }
}
```  
4. 
```
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

public class Main {

    public static void main(String[] args) throws Exception{
        BlockingQueue<String> bq = new SynchronousQueue<>();
        new Thread(()->{
            try{
                System.out.println(Thread.currentThread().getName()+"\t put 1");
                bq.put("1");
                System.out.println(Thread.currentThread().getName()+"\t put 2");
                bq.put("2");
                System.out.println(Thread.currentThread().getName()+"\t put 3");
                bq.put("3");
            }catch (Exception e){
                e.printStackTrace();
            }
        }, "t1").start();

        new Thread(()->{
            try{
                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName()+"\t take "+bq.take());
                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName()+"\t take "+bq.take());
                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName()+"\t take "+bq.take());
            }catch (Exception e){
                e.printStackTrace();
            }
        }, "t2").start();
    }
}
```
- **生产者消费者**  
1.  
```
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ShareData{
    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition cond = lock.newCondition();

    public void incre() throws Exception{
        lock.lock();
        try{
            while (number != 0){
                cond.await();
            }
            number++;
            System.out.println(Thread.currentThread().getName()+"\t"+number);
            cond.signalAll();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void decre() throws Exception{
        lock.lock();
        try{
            while (number == 0){
                cond.await();
            }
            number--;
            System.out.println(Thread.currentThread().getName()+"\t"+number);
            cond.signalAll();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}

public class Main {

    public static void main(String[] args){
        ShareData sd = new ShareData();
        new Thread(()->{
            for (int i = 1; i <= 5; i++) {
                try{
                    sd.incre();
                }catch (Exception e){
                    e.printStackTrace();
                }
            }
        }, "t1").start();
        new Thread(()->{
            for (int i = 1; i <= 5; i++) {
                try{
                    sd.decre();
                }catch (Exception e){
                    e.printStackTrace();
                }
            }
        }, "t2").start();
    }
}
```  
2. synchronized是关键字属于JVM层面，Lock是具体类属于API层面；synchronized不需要手动释放锁，ReentrantLock需要手动释放锁；synchronized不可中断，除非抛出异常或正常运行完成，ReentrantLock可中断，通过设置超时方法tryLock(Long timeout, TimeUnit unit)或者lockInterruptibly调用interrupt()方法来中断；synchronized是非公平锁，ReentrantLock默认是非公平锁，可以通过构造方法设置为公平锁；ReentrantLock可以分组唤醒线程，synchronized只能随机唤醒一个线程或者唤醒全部线程  
3. 线程同步  
```
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ShareData{
    private int number = 1;
    private Lock lock = new ReentrantLock();
    private Condition c1 = lock.newCondition();
    private Condition c2 = lock.newCondition();
    private Condition c3 = lock.newCondition();

    public void print5(){
        lock.lock();
        try{
            while (number != 1){
                c1.await();
            }
            for (int i = 1; i <= 5; i++) {
                System.out.println(Thread.currentThread().getName()+"\t"+i);
            }
            number = 2;
            c2.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void print10(){
        lock.lock();
        try{
            while (number != 2){
                c2.await();
            }
            for (int i = 1; i <= 10; i++) {
                System.out.println(Thread.currentThread().getName()+"\t"+i);
            }
            number = 3;
            c3.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void print15(){
        lock.lock();
        try{
            while (number != 3){
                c3.await();
            }
            for (int i = 1; i <= 15; i++) {
                System.out.println(Thread.currentThread().getName()+"\t"+i);
            }
            number = 1;
            c1.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

}

public class Main {

    public static void main(String[] args){
        ShareData sd = new ShareData();
        new Thread(()->{
            for (int i = 1; i <= 10; i++) {
                sd.print5();
            }
        }, "t1").start();
        new Thread(()->{
            for (int i = 1; i <= 10; i++) {
                sd.print10();
            }
        }, "t2").start();
        new Thread(()->{
            for (int i = 1; i <= 10; i++) {
                sd.print15();
            }
        }, "t3").start();
    }
}
```  
4.  
```
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ShareData{
    private volatile boolean FLAG = true;
    private AtomicInteger ai = new AtomicInteger();

    BlockingQueue<String> bq = null;
    public ShareData(BlockingQueue<String> bq){
        this.bq = bq;
        System.out.println(bq.getClass().getName());
    }

    public void prod() throws Exception{
        String data = null;
        boolean retVal;
        while (FLAG){
            data = ai.incrementAndGet()+"";
            retVal = bq.offer(data, 2L, TimeUnit.SECONDS);
            if (retVal){
                System.out.println(Thread.currentThread().getName()+"\t插入"+data+"成功");
            }else {
                System.out.println(Thread.currentThread().getName()+"\t插入"+data+"失败");
            }
            TimeUnit.SECONDS.sleep(1);
        }
        System.out.println(Thread.currentThread().getName()+"\t停止生产");
    }

    public void consum() throws Exception{
        String res = null;
        while (FLAG){
            res = bq.poll(2L, TimeUnit.SECONDS);
            if (null == res || res.equalsIgnoreCase("")){
                FLAG = false;
                System.out.println(Thread.currentThread().getName()+"\t生产不足，停止消费");
                return;
            }
            System.out.println(Thread.currentThread().getName()+"\t消费"+res+"成功");
        }
    }

    public void stop() throws Exception{
        this.FLAG = false;
    }

}

public class Main {

    public static void main(String[] args) throws Exception{
        ShareData sd = new ShareData(new ArrayBlockingQueue<>(10));
        new Thread(()->{
            System.out.println(Thread.currentThread().getName()+"\t开始生产");
            try{
                sd.prod();
            }catch (Exception e){
                e.printStackTrace();
            }
        }, "prod").start();
        new Thread(()->{
            System.out.println(Thread.currentThread().getName()+"\t开始消费");
            try{
                sd.consum();
            }catch (Exception e){
                e.printStackTrace();
            }
        }, "consum").start();

        try{TimeUnit.SECONDS.sleep(3);}catch (Exception e){
            e.printStackTrace();
        }
        System.out.println("停止生产消费");
        sd.stop();
    }
}
```  
- **Callable**  
1.  
```
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;

class mThread1 implements Runnable{
    @Override
    public void run(){}
}

class mThread2 implements Callable<Integer>{
    @Override
    public Integer call() throws Exception{
        System.out.println("Callable");
        try{
            TimeUnit.SECONDS.sleep(2);
        }catch (Exception e){
            e.printStackTrace();
        }
        return 123;
    }
}

public class Main {

    public static void main(String[] args) throws Exception{
        FutureTask<Integer> ft = new FutureTask<>(new mThread2());
        Thread t1 = new Thread(ft, "t1");
        t1.start();
        int var1 = 100;
        while (!ft.isDone()){}
        int var2 = ft.get();
        System.out.println((var1+var2));
    }
}
```
- **线程池**  
1.  
```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {

    public static void main(String[] args) {
        ExecutorService tp = Executors.newFixedThreadPool(5);
//        Executors.newSingleThreadExecutor();
//        Executors.newCachedThreadPool();
        try{
            for (int i = 1; i <= 10; i++) {
                tp.execute(()->{
                    System.out.println(Thread.currentThread().getName());
                });
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            tp.shutdown();
        }
    }
}
```  
2. newFixedThreadPool创建定长线程池，corePoolSize和maximumPoolSize相等，使用LinkedBlockingQueue  
```
public static ExecutorService newFixedThreadPool(int nThreads){
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
}
```  
3. newSingleThreadExecutor创建单线程化的线程池，corePoolSize和maximumPoolSize都设置为1，使用LinkedBlockingQueue  
```
@NotNull public static ExecutorService newSingleThreadExecutor(){
    return new FinalizableDelegatedExecutorService(
    new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())
    );
}
```  
4. newCachedThreadPool创建可缓存线程池，corePoolSize设置为0，maximumPoolSize设置为Integer.MAX_VALUE，使用SynchronousQueue  
```
@NotNull public static ExecutorService newCachedThreadPool(){
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
}
```  
5. 
```
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue){
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);
}
```  
6.  
a. corePoolSize，线程池中的常驻核心线程数  
b. maximumPoolSize，线程池中能够容纳的同时执行的最大线程数  
c. keepAliveTime，当线程数量超过corePoolSize时，线程空闲时间达到keepAliveTime时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止  
d. unit，keepAliveTime的单位  
e. workQueue，任务队列，存放被提交但未被执行的任务  
f. threadFactory，用于生成线程池中工作线程的线程工厂  
g. handler，拒绝策略，表示当队列满了且工作线程大于等于线程池的最大线程数时拒绝请求的处理策略（AbortPolicy、DiscardPolicy、CallerRunsPolicy、DiscardOldestPolicy）  
7.   
a. 创建线程池后，等待提交过来的任务请求  
b. 当调用execute()方法添加一个请求任务时，线程池会做如下判断：如果正在运行的线程数量小于corePoolSize，则创建线程运行该任务；如果正在运行的线程数量大于或等于corePoolSize，则该任务被放入队列；如果队列已满且正在运行的线程数量小于maximumPoolSize，则创建非核心线程运行该任务；如果队列已满且正在运行的线程数量大于或等于maximumPoolSize，则线程池会根据饱和拒绝策略进行处理  
c. 当线程完成任务时，会从队列中取出下一个任务执行  
d. 当线程空闲超过一定时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于corePoolSize，则该线程会被停止，直到线程池中的线程数等于corePoolSize
8.  
a. AbortPolicy，抛出RejectedExecutionException异常阻止系统正常运行  
b. CallerRunsPolicy，不会丢弃任务，也不会抛出异常，将任务回退给调用者  
c. DiscardOldestPolicy，丢弃队列中等待最久的任务，然后把当前任务加入到队列中尝试再次提交  
d. DiscardPolicy，直接丢弃任务
9. FixedThreadPool和SingleThreadPool允许队列长度为Integer.MAX_VALUE，可能堆积大量请求，导致OOM；CachedThreadPool和ScheduledThreadPool允许创建线程数量为Integer.MAX_VALUE，可能创建大量线程，导致OOM；所以创建线程池不建议使用Executors，而是通过ThreadPoolExecutor的方式创建 
```
import java.util.concurrent.*;

public class Main {

    public static void main(String[] args) {
        ExecutorService ts = new ThreadPoolExecutor(2,5,1L,TimeUnit.SECONDS,
                new LinkedBlockingQueue<Runnable>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy());
    }
}
```  
10. 合理配置线程池考虑点：CPU密集型、IO密集型  
- **死锁**  
```
import java.util.concurrent.TimeUnit;

public class Main implements Runnable{

    private String lockA;
    private String lockB;

    public Main(String lockA, String lockB){
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run(){
        synchronized (lockA){
            System.out.println(Thread.currentThread().getName()+"\t hold："+lockA+"\t try："+lockB);
            try{
                TimeUnit.SECONDS.sleep(2);
            }catch (Exception e){
                e.printStackTrace();
            }
            synchronized (lockB){
                System.out.println(Thread.currentThread().getName()+"\t hold："+lockB+"\t try："+lockA);
            }
        }
    }

    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";

        new Thread(new Main(lockA, lockB),"t1").start();
        new Thread(new Main(lockB, lockA),"t2").start();
    }
}

// jps -l
// jstack 进程号
```  
- **GC Roots**  
1. 虚拟机栈（栈帧中的局部变量区）引用的对象、方法区中的类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象  
- **JVM参数**  
1.  
```
jps -l
jinfo -flag PrintGCDetails 进程号  
// -XX:-PrintGCDetails

// VM options:-XX:+PrintGCDetails
jps -l
jinfo -flag PrintGCDetails 进程号 
// -XX:+PrintGCDetails
```  
2. 是否打印GC收集细节：PrintGCDetails；是否使用串行化垃圾回收器：UseSerialGC  
3.  
```
jps -l
jinfo -flag MetaspaceSize 进程号
// -XX:MetaspaceSize=21807104

// VM options:-XX:MetaspaceSize=1024m
jps -l
jinfo -flag MetaspaceSize 进程号
// -XX:MetaspaceSize=1073741824

jps -l
jinfo -flag MaxTenuringThreshold 进程号
-XX:MaxTenuringThreshold=15

jps -l
jinfo -flags 进程号
```  
4. -Xms等价于-XX:InitialHeapSize；-Xmx等价于-XX:MaxHeapSize  
5. -XX:+PrintFlagInitial，查看初始默认  
```
java -XX:+PrintFlagsInitial -version
```  
6. -XX:+PrintCommandLineFlags，打印命令行参数  
- **JVM**  
1. JDK1.8之后永久代被元空间取代，永久代使用JVM的堆内存，Java8之后的元空间不在虚拟机中而是使用本机物理内存
2. 
```
public class Main{

    public static void main(String[] args) throws Exception{
        long tm = Runtime.getRuntime().totalMemory();
        long mm = Runtime.getRuntime().maxMemory();
        System.out.println("TOTAL_MEMORY(-Xms) = "+(tm/(double)1024/1024)+"MB");
        System.out.println("MAX_MEMORY(-Xmx) = "+(mm/(double)1024/1024)+"MB");
    }
}
```
- **JVM参数**  
1. -Xms，等价于-XX:InitialHeapSize，初始内存大小  
2. -Xmx，等价于-XX:MaxHeapSize，最大分配内存  
3. -Xss，等价于-XX:ThreadStackSize，设置单个线程栈的大小  
4. -Xmn，设置年轻代大小  
5. -XX:MetaspaceSize，设置元空间大小  
6. -XX:+PrintGCDetails，输出详细GC收集日志的信息  
7. -XX:SurvivorRatio，设置新生代中eden和S0/S1空间的比例。默认-XX:SurvivorRatio=8，Eden:S0:S1=8:1:1；如果-XX:SurvivorRatio=4，则Eden:S0:S1=4:1:1  
8. -XX:NewRatio，设置新生代与老年代在堆结构的占比。默认-XX:NewRatio=2，新生代:老年代=1:2  
9. -XX:MaxTenuringThreshold，设置新生代晋升老年代的最大阈值
- **引用**  
1. 对于强引用的对象，即使出现OOM也不会对该对象进行回收，普通的对象引用就是强引用    
```
public class Main{

    public static void main(String[] args) {
        Object o1 = new Object();
        Object o2 = o1;
        o1 = null;
        System.gc();
        System.out.println(o2);
    }
}
```  
2. 软引用可以让对象豁免一些垃圾回收，高速缓存就用到软引用。当内存充足时，不会被回收；当内存不足时，会被回收
```
import java.lang.ref.SoftReference;

public class Main{

    public static void main(String[] args) {
        Object o1 = new Object();
        SoftReference<Object> sr = new SoftReference<>(o1);
        System.out.println(o1);
        System.out.println(sr.get());
        o1 = null;
        System.gc();
        System.out.println(o1);
        System.out.println(sr.get());
        try{
            byte[] bytes = new byte[300*1024*1024];
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            System.out.println(o1);
            System.out.println(sr.get());
        }
    }
}
```  
3. 对于只有弱引用的对象，不管JVM的内存空间是否足够，运行垃圾回收机制都会回收该对象占用的内存  
```
import java.lang.ref.WeakReference;

public class Main{

    public static void main(String[] args) {
        Object o1 = new Object();
        WeakReference<Object> wr = new WeakReference<>(o1);
        System.out.println(o1);
        System.out.println(wr.get());
        o1 = null;
        System.gc();
        System.out.println(o1);
        System.out.println(wr.get());
    }
}
```  
4. 场景：应用需要读取大量的本地图片，若每次都从硬盘读取会严重影响性能，若一次性加载到内存可能会造成内存溢出。使用软引用解决该问题  
```
        Map<String, SoftReference<Byte>> imageCache = new HashMap<>();
```  
5.  
```
import java.util.HashMap;
import java.util.WeakHashMap;

public class Main{

    public static void main(String[] args) {
//        HashMap<Integer,String> m = new HashMap<>();
        WeakHashMap<Integer, String> m = new WeakHashMap<>();
        Integer k = new Integer(1);
        String v = "HashMap";
        m.put(k, v);
        System.out.println(m);
        k = null;
        System.out.println(m);
        System.gc();
        System.out.println(m+"\t"+m.size());
    }
}
```  
6. 虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，则在任何时候都可能被垃圾回收器回收，java.lang.ref.PhantomReference的get方法总是返回null。对象被回收前要先被加入到引用队列（若使用）中，如果发现某个虚引用已经被加入到引用队列中，则可以在所引用的对象的内存被回收之前进行操作，相当于一种通知机制    
```
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;

public class Main{

    public static void main(String[] args) throws Exception{
        Object o1 = new Object();
        ReferenceQueue<Object> rq = new ReferenceQueue<>();
        WeakReference<Object> wr = new WeakReference<>(o1, rq);
        System.out.println(o1);
        System.out.println(wr.get());
        System.out.println(rq.poll());
        o1 = null;
        System.gc();
        Thread.sleep(500);
        System.out.println(o1);
        System.out.println(wr.get());
        System.out.println(rq.poll());
    }
}


import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;

public class Main{

    public static void main(String[] args) throws Exception{
        Object o1 = new Object();
        ReferenceQueue<Object> rq = new ReferenceQueue<>();
        PhantomReference<Object> pr = new PhantomReference<>(o1, rq);
        System.out.println(o1);
        System.out.println(pr.get());
        System.out.println(rq.poll());
        o1 = null;
        System.gc();
        Thread.sleep(500);
        System.out.println(o1);
        System.out.println(pr.get());
        System.out.println(rq.poll());
    }
}
```  
- **OOM**  
1. java.lang.StackOverflowError、java.lang.OutOfMemoryError:java heap space、java.lang.OutOfMemoryError:GC overhead limit exceeded、java.lang.OutOfMemoryError:Direct buffer memory、java.lang.OutOfMemoryError:unable to create new native thread、java.lang.OutOfMemoryError:Metaspace  
2.   
```
public class Main{

    public static void main(String[] args) {
        stackOverflow();
    }

    public static void stackOverflow(){
        stackOverflow();
    }
}
// Exception in thread "main" java.lang.StackOverflowError
```  
3.  
```
java.lang.Object
    java.lang.Throwable
        java.lang.Error
            java.lang.VirtualMachineError
                OutOfMemoryError, StackOverflowError
```  
4.  
```
public class Main{

    public static void main(String[] args) {
        String str = "pkz33";
        while (true){
            str += str;
            str.intern();
        }
        // Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
    }
}
```  
5. GC回收时间过长，会抛出OutOfMemoryError:GC overhead limit execeeded。过长的定义是，超过98%的时间用来做GC并且回收不到%2的堆内存，连续多次GC都回收不到2%的极端情况下会抛出
```
// VM options:-Xms10m -Xmx10m
import java.util.ArrayList;
import java.util.List;

public class Main{

    public static void main(String[] args) {
        int i = 0;
        List<String> l = new ArrayList<>();
        try{
            while (true){
                l.add(String.valueOf(++i).intern());
            }
        }catch (Exception e){
            e.printStackTrace();
            throw e;
        }
    }
}
// Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded
```  
6. 写NIO程序经常使用ByteBuffer进行读取或者写入数据，可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为其引用进行操作，这种做法在一些场景中可以提高性能，因为能避免在Java堆和Native堆中来回复制数据。ByteBuffer.allocate(capability)，分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢；ByteBuffer.allocateDirect(capability)，分配本地内存，不属于GC管辖范围，由于不需要拷贝所以速度相对较快。若不断分配本地内存，堆内存很少使用，则JVM不需要执行GC，DirectByteBuffer对象不会被回收。这会导致堆内存充足，但本地内存不断被消耗，再次尝试分配本地内存可能出现OutOfMemoryError:Direct buffer memory  
```
// -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m
import java.nio.ByteBuffer;

public class Main{

    public static void main(String[] args) {
        System.out.println("MaxDirectMemory:"+(
                sun.misc.VM.maxDirectMemory()/(double)1024/1024)+"MB");
        try{
            Thread.sleep(3000);
        }catch (Exception e){
            e.printStackTrace();
        }
        ByteBuffer bb = ByteBuffer.allocateDirect(6*1024*1024);
    }
}
// Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory
```  
7. 高并发请求服务器时，可能会出现异常OutOfMemoryError:unable to create new native thread，原因是创建的线程太多  
```
public class Main{

    public static void main(String[] args) {
        for (int i = 0; ; i++) {
            new Thread(()->{
                try {
                    Thread.sleep(Integer.MAX_VALUE);
                }catch (Exception e){
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}
// Exception in thread "main" java.lang.OutOfMemoryError: unable to create new native thread
```  
8. java -XX:+PrintFlagsInitial查看初始化参数，永久代（java8后被元空间Metaspace取代）存放：虚拟机加载的类信息、常量池、静态变量、即时编译后的代码 
```
// -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m
package com.pkz33.test;

import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class OOM {
    static class OOMObj{}
    public static void main(String[] args){
        int i = 0;
        try{
            while (true){
                i++;
                Enhancer enhancer = new Enhancer();
                enhancer.setSuperclass(OOMObj.class);
                enhancer.setUseCache(false);
                enhancer.setCallback(new MethodInterceptor() {
                    @Override
                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                        return methodProxy.invokeSuper(o, args);
                    }
                });
                enhancer.create();
            }
        }catch (Exception e){
            System.out.println(i);
            e.printStackTrace();
        }
    }
}
// org.springframework.cglib.core.CodeGenerationException: java.lang.OutOfMemoryError-->Metaspace
```
- **垃圾收集器**  
1. 串行垃圾回收器（Serial）、并行垃圾回收器（Parallel）、并发垃圾回收器（CMS）、G1垃圾回收器  
2. Serial，单线程环境，只使用一个线程进行垃圾回收，会暂停所有用户线程，不适合服务器环境   
3. Parallel，多个垃圾收集线程并行工作，会暂停用户线程，适用于科学计算/大数据处理首台处理等弱交互场景  
4. CMS，用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要暂停用户线程，适用于对响应时间有要求的场景  
5. G1，将堆内存分割成不同的区域然后并发的对其进行垃圾回收  
6. `java -XX:+PrintCommandLineFlags -version`，可以查看默认垃圾收集器`-XX:+UseParallelGC`。java的gc回收类型主要有：UseSerialGC、UseParallelGC、UseConcMarkSweepGC、UseParNewGC、UseParallelOldGC、UseG1GC  
7. 对于单CPU环境，Serial垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器。设置JVM参数`-XX:+UseSerialGC`后，开启Serial(Young区)+Serial Old(Old区)的收集器组合，新生代、老年代使用串行收集器，新生代使用复制算法，老年代使用标记-整理算法  
8. ParNew收集器是Serial收集器新生代的并行多线程版本，最常见的应用场景是配合老年代的CMS GC工作，它是许多java虚拟机运行在Server模式下新生代的默认垃圾收集器。设置JVM参数`-XX:+UseParNewGC`后，开启ParNew(Young区)+Serial Old(Old区)的收集器组合，新生代使用复制算法，老年代使用标记-整理算法  
9. Parallel Scavenge收集器类似ParNew，也是新生代垃圾收集器，使用复制算法，也是并行多线程的垃圾收集器。自适应调节策略是ParallelScavenge收集器与ParNew收集器的一个重要区别，虚拟机根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间（-XX:MaxGCPauseMills）或最大吞吐量。-XX:ParallelGCThreads=N，表示启动N个GC线程  
10. Parallel Old收集器是Parallel Scavenge的老年代版本，使用标记-整理算法。Parallel Old是为了搭配Parallel Scavenge来提高老年代吞吐量而产生的（相较于Parallel Scavenge+Serial Old）。设置JVM参数`-XX:+UseParallelOldGC`后，开启Parallel(Young区)+Parallel Old(Old区)的收集器组合  
11. CMS（Concurrent Mark Sweep）收集器，是以获取最短回收停顿时间为目标的收集器，并发指的是与用户线程同时执行。设置JVM参数`-XX:+UseConcMarkSweepGC`后，开启ParNew(Young区)+CMS(Old区)+Serial Old(Old区备用)的收集器组合。步骤：初始标记（仅标记与GC Roots直接关联的对象，要暂停所有工作线程）、并发标记（标记全部对象，不需要暂停工作线程）、重新标记（修正并发标记期间因工作线程继续运行而导致标记产生变动的对象的标记记录，需要暂停所有工作线程）、并发清除（清除不可达对象，不需要暂停工作线程）。优点，并发收集低停顿；缺点，并发执行，CPU资源压力大，采用标记-清除算法会导致空间碎片。设置参数`-XX:CMSFullGCsForeCompaction`可以指定多少次CMS收集后进行
一次压缩的Full GC  
12. Serial Old是Serial垃圾收集器的老年代版本，单线程收集器，使用标记-整理算法  
13. 单CPU或小内存，单机程序，-XX:+UseSerialGC；多CPU，需要大吞吐量，如后台计算型应用，-XX:+UseParallelGC或者-XX:+UseParallelOldGC；多CPU，追求低停顿时间，需要快速响应，如互联网应用，-XX:+UseConcMarkSweepGC，-XX:+ParNewGC  
14. G1(Garbage-First)收集器，应用在多处理器和大内存场景中，在实现高吞吐量的同时，尽可能满足垃圾收集暂停时间的要求，与应用程序线程并发执行。与CMS相比，在垃圾收集过程中可以整理内存，从而减少内存碎片，在停顿时间上添加了预测机制，STW(Stop The World)可控，用户可以指定期望停顿时间。Eden、Survivor和Tenured等内存区域不再连续，而是变成许多region，每个region从1M到32M不等，一个region可能属于Eden、Survivor或者Tenured。G1是分代收集器，逻辑上分代，整体采用标记-整理算法，局部采用复制算法。通过参数`-XX:G1HeapRegionSize=N`指定region的大小（值必须是2的幂）。对新生代的垃圾收集要暂停所有应用线程，对老年代的收集会进行部分堆的压缩。G1中存在特殊区域Humongous区，存放巨型对象（超过分区容量50%以上）  
15. G1步骤：初始标记、并发标记、最终标记、筛选回收  
16. G1常用参数：-XX:+UseG1GC、-XX:G1HeapRegionSize=n、-XX:MaxGCPauseMillis=n、-XX:InitiatingHeapOccupancyPercent=n、-XX:ConcGCThreads=n、-XX:G1ReservePercent=n  
17. java -server JVM参数 -jar  
- **性能监控**  
1. 整机-top、CPU-vmstat、内存-free、硬盘-df、磁盘IO-iostat、网络IO-ifstat、平均负载（1\5\15minute）-uptime  
2. top命令查找CPU占比最高；ps -ef或者jps进一步定位；根据进程号定位到具体线程或代码；jstack 进程号 | grep 线程号
- **intern()**  
1. `@NotNull public native String intern();`  
2. String::intern()是本地方法，作用是如果字符串常量池中已经包含等于此String对象的字符串，则返回代表池中该字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池，并返回此String对象的引用  
3. 特殊情况，字符串`java`在加载sun.misc.Version类时加入常量池  
```
public class Version {
    private static final String launcher_name = "java";
    // ...
}
```
4.  
```
public class Main{

    public static void main(String[] args) {
        String s1 = new StringBuilder("pkz").append("33").toString();
        System.out.println(System.identityHashCode(s1));
        System.out.println(System.identityHashCode(s1.intern()));
        System.out.println(s1.intern() == s1); // true

        String s2 = new StringBuilder("ja").append("va").toString();
        System.out.println(System.identityHashCode(s2));
        System.out.println(System.identityHashCode(s2.intern()));
        System.out.println(s2.intern() == s2); // false
    }
}
```  
- **可重入锁**  
1. ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可以在一定程度上避免死锁  
2. 隐式锁（synchronized关键字）、显式锁（Lock）  
3. 
```
public class Main{

    static Object o1 = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (o1){
                System.out.println(Thread.currentThread().getName()+"\t"+"外层调用");
                synchronized (o1){
                    System.out.println(Thread.currentThread().getName()+"\t"+"中层调用");
                    synchronized (o1){
                        System.out.println(Thread.currentThread().getName()+"\t"+"内层调用");
                    }
                }
            }
        }, "t1").start();
    }
}


public class Main{

    public synchronized static void m1(){
        System.out.println("外层");
        m2();
    }

    public synchronized static void m2(){
        System.out.println("中层");
        m3();
    }

    public synchronized static void m3(){
        System.out.println("内层");
    }

    public static void main(String[] args) {
        m1();
    }
}


import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Main{

    static Lock lock = new ReentrantLock();

    public static void main(String[] args) {
        new Thread(() -> {
            lock.lock();
            try{
                System.out.println("外层");
                lock.lock();
                try{
                    System.out.println("内层");
                }finally {
                    lock.unlock();
                }
            }finally {
                lock.unlock();
            }
        }, "t1").start();
    }
}
```
- **LockSupport**  
1. 用于创建锁和其他同步类的基本线程阻塞原语，park()和unpark()的作用分别是阻塞线程和解除阻塞线程（synchronized：wait/notify，lock：await/signal）   
2. Object的wait()方法让线程等待，notify()方法唤醒线程；JUC包中Condition的await()方法让线程等待，signal()方法唤醒线程；LockSupport类可以阻塞当前线程以及唤醒指定被阻塞线程  
```
public class Main{

    static Object o1 = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
//            try{  // notify在wait之前，程序将无法被唤醒
//                TimeUnit.SECONDS.sleep(3);
//            }catch (Exception e){
//                e.printStackTrace();
//            }
            synchronized (o1){  // java.lang.IllegalMonitorStateException
                System.out.println(Thread.currentThread().getName());
                try{
                    o1.wait();
                }catch (Exception e){
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+"\t 被唤醒");
            }
        }, "A").start();

        new Thread(() -> {
            synchronized (o1){
                o1.notify();
                System.out.println(Thread.currentThread().getName()+"\t 执行唤醒");
            }
        }, "B").start();
    }
}


import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Main{

    static Lock lock = new ReentrantLock();
    static Condition cond = lock.newCondition();

    public static void main(String[] args) {
        new Thread(() -> {
//            try{  // signal在await之前，程序将无法被唤醒
//                TimeUnit.SECONDS.sleep(3);
//            }catch (Exception e){
//                e.printStackTrace();
//            }
            lock.lock();
            try{
                System.out.println(Thread.currentThread().getName());
                try{
                    cond.await();
                }catch (Exception e){
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+"\t 被唤醒");
            }finally {
                lock.unlock();
            }
        }, "A").start();

        new Thread(() -> {
            lock.lock();
            try{
                cond.signal();
                System.out.println(Thread.currentThread().getName()+"\t 执行唤醒");
            }finally {
                lock.unlock();
            }
        }, "B").start();
    }
}
```  
3. LockSupport类使用名为Permit的概念，每个线程都有一个Permit，Permit只有0和1两个值，与信号量Semaphore不同的是，Permit的累加上限是1。执行一次unpark会使Permit变成1，但Permit最大只能是1，累加无效；执行一次park会使Permit从1变成0  
```
public static void park() {
    UNSAFE.park(false, 0L);
}

public static void unpark(Thread thread) {
    if (thread != null)
        UNSAFE.unpark(thread);
}


import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;

public class Main{

    public static void main(String[] args) {
        Thread a = new Thread(() -> {
            try{
                TimeUnit.SECONDS.sleep(3L);
            }catch (Exception e){
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"\t"+System.currentTimeMillis());
            LockSupport.park();
            System.out.println(Thread.currentThread().getName()+"\t 被唤醒\t"+System.currentTimeMillis());
        }, "A");
        a.start();

        new Thread(() -> {
            LockSupport.unpark(a);
            System.out.println(Thread.currentThread().getName()+"\t 执行唤醒\t"+System.currentTimeMillis());
        }, "B").start();
    }
}


import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;

public class Main{

    public static void main(String[] args) {
        Thread a = new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+"\t"+System.currentTimeMillis());
            LockSupport.park();
            LockSupport.park();
            System.out.println(Thread.currentThread().getName()+"\t 被唤醒\t"+System.currentTimeMillis());
        }, "A");
        a.start();

        try{
            TimeUnit.SECONDS.sleep(3L);
        }catch (Exception e){
            e.printStackTrace();
        }

        new Thread(() -> {
            LockSupport.unpark(a);
            LockSupport.unpark(a);
            System.out.println(Thread.currentThread().getName()+"\t 执行唤醒\t"+System.currentTimeMillis());
        }, "B").start();
    }
}
```   
- **AQS**  
1. AbstractQueuedSynchronizer，通过volatile的int类型的成员变量表示同步状态，将线程封装到Node节点并加入到FIFO队列实现锁的分配，通过CAS修改变量state的值  
```
public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
    /**...*/
    
    static final class Node {//...}
    
    private transient volatile Node head;
    
    private transient volatile Node tail;
    
    private volatile int state;
    
    /**...*/
}

static final class Node {
    static final Node SHARED = new Node();
    
    static final Node EXCLUSIVE = null;
    
    static final int CANCELLED = 1;
    
    static final int SIGNAL = -1;
    
    static final int CONDITION = -2;
    
    static final int PROPAGATE = -3;
    
    volatile int waitStatus;
    
    volatile Node prev;
    
    volatile Node next;
    
    volatile Thread thread;
    
    Node nextWaiter;
    
    final boolean isShared() {
        return nextWaiter == SHARED;
    }
}
```  
2.  
``` 
public class ReentrantLock implments Lock, java.io.Serializable {
    /**...*/
    
    private final Sync sync;
    
    abstract static class Sync extends AbstractQueuedSynchronizer {
        /**...*/
    }
    
    static final class NofairSync extends Sync {
        /**...*/
        
        final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
    }
    
    static final class FairSync extends Sync {
        /**...*/
    }
    
    public ReentrantLock() {
        sync = new NofairSync();
    }
    
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NofairSync();
    }
    
    public void lock() {
        sync.lock();
    }
    
    public void unlock() {
        sync.release(1);
    }
    
    /**...*/
}
```  
3. 对比公平锁和非公平锁的tryAcquire()方法的实现代码，差别在于非公平锁获取锁时比公平锁少了一个判断!hasQueuedPredecessors()。hasQueuedPredecessors()中判断是否需要排队，导致公平锁和非公平锁的差异如下：公平锁，线程在获取锁时，如果该锁的等待队列中已经有线程等待，则当前线程进入等待队列；非公平锁，若可以获取锁则立刻获取锁对象  
4. AQS关键词：state标识锁状态（0-被释放、1-被持有），通过CAS修改；双向队列，放置等待线程Node，第一个节点为哨兵节点，不存储线程的信息；LockSupport  
- **AOP**  
1. 通知类型  
```
@Before // 前置通知
@After // 后置通知
@AfterReturning // 返回后通知
@AfterThrowing // 异常通知  
@Around // 环绕通知
```  
2. @Aspect，指定类为切面类；@Component，加入到容器中  
3. 通知顺序：Spring4/SpringBoot1.x.x，@Before -> @After -> @AfterReturning/@AfterThrowing；Spring5/SpringBoot2.x.x，@Before -> @AfterReturing/@AfterThrowing -> @After  
- **循环依赖**  
1. 若注入依赖方式是通过setter，且是singleton模式，则不会引入循环依赖问题；通过构造器依赖注入，若出现循环依赖，无法解决
2. org.springframework.beans.factory.BeanCurrentlyInCreationException  
3. 单例（singleton）场景支持循环依赖，原型（prototype）场景不支持循环依赖  
4. spring内部通过三级缓存解决循环依赖问题，只适用于单例bean，对于非单例bean，每次从容器中获取都是一个新的对象，会重新创建，不会放入三级缓存中  
5. 第一级缓存（单例池），singletonObjects，存放经历完整生命周期的bean对象（完成实例化和初始化）；第二级缓存，earlySingletonObjects，存放提前暴露的bean对象（完成实例化(分配内存)，未完成初始化(属性填充)）；第三级缓存，Map<String, ObjectFactory<?>> singletonFactories，存放生成bean的工厂bean    
```
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
    
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);
    
    private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);
    
    private final Set<String> registeredSingletons = new LinkedHashSet<>(256);
    
    private final Set<String> singletonCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap<>(16));
    
    /**...*/
    // getSingleton
    // doCreateBean
    // populateBean
    // addSingleton
}
```  
6. 假设A和B存在循环依赖，则A和B的相关bean对象在三级缓存中的迁移过程：  
a. A创建过程中依赖B，A先将产生自己的工厂bean放入三级缓存，然后去实例化B  
b. B创建过程中依赖A，B先查询一级缓存，未查到，再查询二级缓存，未查到，再查询三级缓存，通过产生A的bean工厂生成A并放入二级缓存，同时删除三级缓存中的A  
c. B完成初始化并将自己放入一级缓存，然后A进行初始化，从一级缓存中获取B，完成初始化后将自己放入一级缓存  
7. 假设A、B循环引用，实例化A的时候将其放入三级缓存，然后初始化时发现依赖B；同样流程B实例化后放入三级缓存，B初始化时发现依赖A；B从缓存中查询到提前暴露的A，若没有AOP代理，则直接将A的原始对象注入B，完成B的初始化，然后完成A剩下的步骤；若有AOP代理，则进行AOP处理获取A的代理对象，注入B，然后完成剩下的流程  
- **redis**  
1. 数据类型：String/ Hash/ List/ Set/ SortedSet/ Bitmap/ HyperLogLog/ GEO  
2. 命令不区分大小写，key区分大小写  
3. 基本用法  
```
SET key value
GET key

MSET key value [key value ...]
MGET key [key ...]

INCR key
INCRBY key increment
DECR key
DECRBY key decrement

STRLEN key

SETNX key value
SET key value [EX seconds] [PX milliseconds] [NX|XX]

TTL key

DEL key
```  
4. Hash用法  
```
HSET key field value
HGET key field

HMSET key field value [field value ...]
HMGET key field [field ...]

HGETALL key

HLEN key

HDEL key field

// 购物车案例
// 新增商品
HSET shopcar:uid001 123456 1
HSET shopcar:uid001 123457 1
// 增加商品数量
HINCRBY shopcar:uid001 123456 2
// 商品种类数
HLEN shopcar:uid001
// 全选
HGETALL shopcar:uid001
```  
5. List用法  
```
LPUSH key value [value ...]
RPUSH key value [value ...]

LRANGE key start stop

LLEN key

// 微信文章订阅
LPUSH likearticle:uid001 a1 a2
// 查看全部订阅
LRANGE likearticle:uid001 0 -1
```  
6. Set用法  
```
SADD key member [member ...]

SREM key member [member ...]

SMEMBERS key

SISMEMBER key member

SCARD key

SRANDMEMBER key [数字]

SPOP key [数字]

// 微信抽奖
SADD s1 1 2 3 4 5 6 7 8 9 10
// 显示参与人数
SCARD s1
// 随机抽三个人
SRANDMEMBER s1 3
SPOP s1 3

// 微信朋友圈点赞
// 点赞
SADD pub:msg001 uid001 uid002 uid003
// 取消点赞
SREM pub:msg001 uid001
// 显示所有点赞用户
SMEMBERS pub:msg001
// 统计点赞用户数
SCARD pub:msg001
// 判断某人是否点赞
SISMEMBER pub:msg001 uid002

// 共同关注的人
SADD s1 1 2 3 4 5 s2
SADD s2 3 4 5 6 7
SINTER s1 s2
// 我关注的人(s2)也关注他(3)
SISMEMBER s1 3
SISMEMBER s2 3

// 可能认识的人
SDIFF s1 s2
SDIFF s2 s1
```  
7. Zset用法  
```
ZADD key score member [score member ...]

ZRANGE key start stop [WITHSCORES]

ZSCORE key member

ZREM key member [member ...]

ZRANGEBYSCORE key min max [WITHSCORES]

ZINCRBY key increment member

ZCARD key

ZCOUNT key min max

ZREMRANGEBYRANK key start stop

ZRANK key member

ZREVRANK key member

// 根据商品销售量对商品排序显示
ZADD goods:zset 9 1001 15 1002 4 1003
ZINCRBY goods:zset 2 1001
ZRANGE goods:zset 0 10 WITHSCORES

// 抖音热搜
ZADD hot:2021 1 mv1 3 mv2 16 mv3 2 mv4
ZREVRANGE hot:2021 0 -1 WITHSCORES
```
