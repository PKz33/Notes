## 重点
- **volatile**  
1. JVM提供的轻量级同步机制  
2. 保证可见性、不保证原子性、禁止指令重排  
- **JMM**  
1. JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，描述一组规则或规范，定义程序中各个变量的访问方式  
2. JMM关于同步的规定  
a. 线程解锁前，必须把共享变量的值刷新回主内存  
b. 线程加锁前，必须读取主内存的最新值到当前线程的工作内存  
c. 加锁解锁是用一把锁  
3. 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（栈空间），工作内存是每个线程的私有数据区域。Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行。首先将变量从主内存拷贝到工作内存，然后对变量进行操作，操作完成后再将变量写回主内存。不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信通过主内存完成。  
4. 代码演示可见性  
```
import java.util.concurrent.TimeUnit;

class Data{
//    int number = 0;
    volatile int number = 0;
    public void add(){
        this.number = 60;
    }
}

public class Main {
    public static void main(String[] args) {
        Data data = new Data();
        new Thread(()->{
            System.out.println(Thread.currentThread().getName());
            try{
                TimeUnit.SECONDS.sleep(3);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            data.add();
            System.out.println(Thread.currentThread().getName()+"\t"+data.number);
        },"AA").start();
        while (data.number == 0){
            // 理论上，上面线程将number值修改为60后
            // main线程会终止当前循环，main线程结束
            // 实际运行情况是main线程继续循环没有结束

            // 用volatile修饰后，main线程结束，即volatile保证可见性
        }
        System.out.println(Thread.currentThread().getName());
    }
}

```
