## 重点
- **volatile**  
1. JVM提供的轻量级同步机制  
2. 保证可见性、不保证原子性、禁止指令重排  
- **JMM**  
1. JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，描述一组规则或规范，定义程序中各个变量的访问方式  
2. JMM关于同步的规定  
a. 线程解锁前，必须把共享变量的值刷新回主内存  
b. 线程加锁前，必须读取主内存的最新值到当前线程的工作内存  
c. 加锁解锁是用一把锁  
3. 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（栈空间），工作内存是每个线程的私有数据区域。Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行。首先将变量从主内存拷贝到工作内存，然后对变量进行操作，操作完成后再将变量写回主内存。不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信通过主内存完成    
4. 代码演示可见性  
```
import java.util.concurrent.TimeUnit;

class Data{
//    int number = 0;
    volatile int number = 0;
    public void add(){
        this.number = 60;
    }
}

public class Main {
    public static void main(String[] args) {
        Data data = new Data();
        new Thread(()->{
            System.out.println(Thread.currentThread().getName());
            try{
                TimeUnit.SECONDS.sleep(3);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            data.add();
            System.out.println(Thread.currentThread().getName()+"\t"+data.number);
        },"AA").start();
        while (data.number == 0){
            // 理论上，上面线程将number值修改为60后
            // main线程会终止当前循环，main线程结束
            // 实际运行情况是main线程继续循环没有结束

            // 用volatile修饰后，main线程结束，即volatile保证可见性
        }
        System.out.println(Thread.currentThread().getName());
    }
}

```  
5. 不保证原子性  
```
class Data{
    volatile int number = 0;

    public void addPlus(){
        number++;
    }
}

public class Main {
    public static void main(String[] args) {
        Data data = new Data();

        for(int i = 1;i <= 20;i++){
            new Thread(() -> {
                for (int j = 1;j <= 1000;j++){
                    data.addPlus();
                }
            },String.valueOf(i)).start();
        }


        while (Thread.activeCount() > 2){
            Thread.yield();
        }
        
        // 多次执行，number的最终值不同
        System.out.println(Thread.currentThread().getName()+"\t"+data.number);
    }
}
```
6. 保证原子性的方法  
a. 用synchronized解决  
b.   
```
import java.util.concurrent.atomic.AtomicInteger;

class Data{
    AtomicInteger atomicInteger = new AtomicInteger();

    public void addAtomic(){
        atomicInteger.getAndIncrement();
    }
}

public class Main {
    public static void main(String[] args) {
        Data data = new Data();

        for(int i = 1;i <= 20;i++){
            new Thread(() -> {
                for (int j = 1;j <= 1000;j++){
                    data.addAtomic();
                }
            },String.valueOf(i)).start();
        }


        while (Thread.activeCount() > 2){
            Thread.yield();
        }

        System.out.println(Thread.currentThread().getName()+"\t"+data.atomicInteger);
    }
}
```  
7. 计算机在执行程序时，为了提高性能，编译器和处理器通常会对指令做重排（编译器优化的重排、指令并行的重排、内存系统的重排）。处理器在进行重排时必须考虑指令之间的数据依赖性。多线程环境中线程交替执行，由于编译器优化重排的存在，多个线程中使用的变量能否保证一致性是无法确定的，结果无法预测    
8. 内存屏障又称内存栅栏，是一个CPU指令，有两个作用：一是保证特定操作的执行顺序，二是保证某些变量的内存可见性。编译器和处理器都能执行指令重排优化，通过插入内存屏障，禁止在内存屏障前后的指令执行重排优化，内存屏障的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到数据的最新版本。对volatile修饰的变量进行写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新回主内存；进行读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量值  
9. 单例模式中应用volatile  
```
public class Singleton{
    private static volatile Singleton instance = null;
    private Singleton(){
    }
    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    // 1.分配对象内存空间
                    // 2.初始化对象
                    // 3.设置instance指向分配的内存地址
                    // 2和3不存在数据依赖关系
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```  
- **CAS**  
1. 源码  
```
public final boolean compareAndSet(int expect, int update){
    // valueOffset，表示变量值在内存中的偏移地址
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}

public final int getAndIncrement(){
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
```  
2. 
```
import java.util.concurrent.atomic.AtomicInteger;

public class Main {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(5);
        System.out.println(atomicInteger.compareAndSet(5,2021)+"\t"+atomicInteger.get());
        System.out.println(atomicInteger.compareAndSet(5,1024)+"\t"+atomicInteger.get());
    }
}

```  
3. Unsafe类事CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问。Unsafe类在sun.misc包中，其内部方法可以像C语言的指针一样直接操作内存，CAS操作的执行依赖于Unsafe类的方法。Unsafe类中的所有方法都是native修饰的，即Unsafe类中的方法都直接调用操作系统底层资源执行相应任务  
4. CAS全称是Compare-And-Swap，是一条CPU并发原语。CAS依赖于硬件，实现原子操作，是一种系统原语。原语属于操作系统用语范畴，由若干条指令组成，用于完成某个功能。原语的执行是连续的，在执行过程中不允许被中断，即CAS是一条CPU原子指令，不会造成数据不一致问题  
5. CAS缺点：自旋，循环时间长开销大；只能保证一个共享变量的原子操作；ABA问题  
```
// Unsafe.getAndAddInt
public final int getAndAddInt(Object var1, long var2, int var4){
    int var5;
    do{
        var5 = this.getIntVolatile(var1, var2);
    }while(!this.compareAndSwapInt(var1, var2, var5, var5+var4));
    return var5;
}
```  
6. 
```
import java.util.concurrent.atomic.AtomicReference;

class User{
    String name;
    int age;
    public User(String name, int age){
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return this.name+"\t"+this.age;
    }
}

public class Main {
    public static void main(String[] args) {
        AtomicReference<User> atomicReference = new AtomicReference<>();
        User z3 = new User("z3", 22);
        User l4 = new User("l4", 23);
        atomicReference.set(z3);
        System.out.println(atomicReference.compareAndSet(z3,l4)+"\t"+atomicReference.get().toString());
    }
}
```  
7. ABA问题  
```
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class Main {
    static AtomicReference<Integer> ar = new AtomicReference<>(100);
    public static void main(String[] args) {
        new Thread(()->{
            ar.compareAndSet(100,101);
            ar.compareAndSet(101,100);
        },"t1").start();
        new Thread(()->{
            try{TimeUnit.SECONDS.sleep(1);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            System.out.println(ar.compareAndSet(100,2021)+"\t"+ar.get());
        },"t2").start();
    }
}
```  
8. ABA问题解决  
```
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicStampedReference;

public class Main {
    // static AtomicReference<Integer> ar = new AtomicReference<>(100);
    static AtomicStampedReference<Integer> ar = new AtomicStampedReference<>(100,1);
    public static void main(String[] args) {
        int stamp = ar.getStamp();
        new Thread(()->{
            ar.compareAndSet(100,101,stamp,stamp+1);
            ar.compareAndSet(101,100,ar.getStamp(),ar.getStamp()+1);
        },"t1").start();
        new Thread(()->{
            try{TimeUnit.SECONDS.sleep(1);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            System.out.println(ar.compareAndSet(100,2021,stamp,stamp+1)+"\t"+ar.getReference());
        },"t2").start();
    }
}
```  
9. 集合类不安全的问题  
```
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class Main {
    // java.util.ConcurrentModificationException
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        for(int i = 1;i <= 30;i++){
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
```  
10. 集合不安全问题的解决方法  
```
// 使用Vector
List<String> list = new Vector<>();

// 使用Collections工具类
List<String> list = Collections.synchronizedList(new ArrayList<>());
// Collections.synchronizedSet()
// Collections.synchronizedMap()

// 使用CopyOnWriteArrayList
List<String> list = new CopyOnWriteArrayList<>();
```  
11. CopyOnWrite容器即写时复制的容器，往容器添加元素的时候，并不直接往当前容器Object[]添加，而是先将当前容器Object[]进行copy，复制出一个新的容器Object[] newElements，让后向新容器Object[] newElements添加元素，添加完元素之后，再将原容器的引用指向新容器setArray(newElements)。这样就可以进行并发的读，而不需要加锁，这是一种读写分离的思想，读和写不同的容器  
