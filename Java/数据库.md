## 数据库
- **SQL分类**
1. DDL（Data Definition Language）数据定义语言，用来定义数据库对象：数据库，表，列等。关键字：`create`，`drop`，`alter`等
2. DML（Data Manipulation Language）数据操作语言，用来对数据库中表的数据进行增删改。关键字：`insert`，`delete`，`update`等
3. DQL（Data Query Language）数据查询语言，用来查询数据库中表的记录（数据）。关键字：`select`，`where`等
4. DCL（Data Control Language）数据控制语言（了解）
- **操作数据库**
1. C（Create）：创建
```
  // 创建数据库
  create database 数据库名称;
  // 创建数据库，判断不存在则创建
  create database if not exists 数据库名称;
  // 创建数据库，并指定字符集
  create database 数据库名称 character set 字符集名;
  
  // 创建db数据库，判断是否存在，并指定字符集为gbk
  create database if not exists db character set gbk;
```
2. R（Retrieve）：查询
```
  // 查询所有数据库的名称
  show databases;
  // 查询某个数据库的字符集：查询某个数据库的创建语句
  show create database 数据库名称;
```
3. U（Update）：修改
```
  // 修改数据库的字符集
  alter database 数据库名称 character set 字符集名称;
```
4. D（Delete）：删除
```
  // 删除数据库
  drop database 数据库名称;
  // 判断数据库存在，存在则删除
  drop database if exists 数据库名称;
```
5. 使用数据库
```
  // 查询当前正在使用的数据库名称
  select database();
  // 使用数据库
  use 数据库名称;
```
- **操作表**
1. C（Create）：创建
```
  // 语法
  create table 表名(
    列名1 数据类型1,
    列名2 数据类型2,
    ...
    列名n 数据类型n
  );
  // 最后一列不需要加逗号
  
  // 数据库类型：
  // 1. int：整数类型
  age int
  
  // 2. double：小数类型
  score double(5,2)
  
  // 3. date：日期，只包含年月日 yyyy-MM-dd
  
  // 4. datetime：日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss
  
  // 5. timestamp：时间戳类型，包含年月日时分秒 yyyy-MM-dd HH:mm:ss
  // 如果不给这个类型字段赋值，或者赋值为null，则默认使用当前的系统时间自动赋值
  
  // 6. varchar：字符串
  // 最大20个字符
  name varchar(20)
  // zhangsan 8个字符  张三 2个字符
```
2. R（Retrieve）：查询
```
  // 查询某个数据库中所有的表
  show tables;
  
  // 查询表结构
  desc 表名; 
  
  // 复制表
  create table 表名 like 被复制的表名;
```
3. D（Delete）：删除
```
  drop table 表名;
  drop table if exists 表名;
```
4. U（Update）：修改
```
  // 修改表名
  alter table 表名 rename to 新的表名;
  
  // 修改表的字符集
  alter table 表名 character set 字符集名称;
  
  // 添加一列
  alter table 表名 add 列名 数据类型;
  
  // 修改列名称 类型
  alter table 表名 change 列名 新列名 新数据类型;
  alter table 表名 modify 列名 新数据类型;
  
  // 删除列
  alter table 表名 drop 列名; 
```
- **操作数据**
1. 删除
```
  // 如果要删除所有记录
  delete from 表名;  -- 不建议使用，有多少条记录就会执行多少次删除操作
  truncate table 表名;  -- 建议使用，效率更高，先删除表，然后再创建一张一样的表
```
2. 查询
```
  // 语法
  select
    字段列表
  from
    表名列表
  where
    条件列表
  group by
    分组字段
  having
    分组之后的条件
  order by
    排序
  limit
    分页限定
  
  // 基础查询
  // 多个字段的查询
  SELECT 字段名1, 字段名2... FROM 表名;
  // 如果查询所有字段，则可以使用*代替字段列表
  
  // 去除重复
  DISTINCT
  
  // 计算列
  // 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）
  // null参与的运算，计算结果都为null
  // 表达式1：哪个字段需要判断是否为null
  // 表达式2：如果该字段为null后的替换值
  IFNULL(表达式1, 表达式2)
  
  // 起别名
  AS
  // AS也可以省略
    
  // 去除重复的结果集
  SELECT DISTINCT address FROM student;
  SELECT DISTINCT name, address FROM student;
  
  // 如果有null参与的运算，计算结果都为null
  SELECT name, math, english, math + english FROM student;
  SELECT name, math, english, math + IFNULL(english, 0) FROM student;
  
  // 起别名
  SELECT name, math, english, math + IFNULL(english, 0) AS 总分 FROM student;
  SELECT name, math 数学, english 英语, math + IFNULL(english, 0) 总分 FROM student;
  
  // 查询年龄大于等于20小于等于30
  SELECT * FROM student WHERE age >= 20 && age <= 30;
  SELECT * FROM student WHERE age >= 20 AND age <= 30;
  SELECT * FROM student WHERE age BETWEEN 20 AND 30;
  
  // 查询年龄22岁，18岁，25岁的信息
  SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25;
  SELECT * FROM student WHERE age IN (22, 18, 25);
  
  // 查询英语成绩为null
  // 错误写法，null值不能使用=（!=）判断
  -- SELECT * FROM student WHERE english = NULL;
  // 正确写法
  SELECT * FROM student WHERE english IS NULL;
  // 查询英语成绩不为null
  SELECT * FROM student WHERE english IS NOT NULL;
  
  // 查询姓马的有哪些 LIKE
  SELECT * FROM student WHERE name LIKE '马%';
  // 查询姓名第二个字是化的人
  SELECT * FROM student WHERE name LIKE "_化%";
  // 查询姓名是3个字的人
  SELECT * FROM student WHERE name LIKE '___';
  // 查询姓名中包含德的人
  SELECT * FROM student WHERE name LIKE '%德%';
  
  // 排序查询
  // 语法 ORDER BY 排序字段1 排序方式1, 排序字段2 排序方式2...
  // 排序方式 ASC：升序，默认的  DESC：降序
  // 如果有多个排序条件，则当前边的条件值一样时，才会判断第二个条件
  SELECT * FROM student ORDER BY math ASC;
  SELECT * FROM student ORDER BY math DESC;
  // 按照数学成绩排名，如果数学成绩一样，则按照英语成绩排名
  SELECT * FROM student ORDER BY math ASC, english ASC;
  
  // 聚合函数：将一列数据作为一个整体，进行纵向的计算
  // COUNT：计算个数，一般选择非空的列，主键
  // MAX：计算最大值
  // MIN：计算最小值
  // SUM：计算和
  // AVG：计算平均值
  // 聚合函数的计算，排除null值
  // 选择不包含非空的列进行计算，IFNULL函数
  SELECT COUNT(english) FROM student;
  SELECT COUNT(IFNULL(english, 0)) FROM student;
  SELECT COUNT(id) FROM student;
  SELECT MAX(math) FROM student;
  SELECT MIN(math) FROM student;
  SELECT SUM(english) FROM student;
  SELECT AVG(math) FROM student;
  
  // 分组查询
  // 语法：GROUP BY 分组字段;
  // 分组之后查询的字段：分组字段、聚合函数
  // 按照性别分组，分别查询男、女同学的平均分
  SELECT sex, AVG(math) FROM student GROUP BY sex;
  // 按照性别分组，分别查询男、女同学的平均分，人数
  SELECT sex, AVG(math), COUNT(id) FROM student GROUP BY sex;
  // 按照性别分组，分别查询男、女同学的平均分，人数。要求分数低于70分的人，不参与分组
  SELECT sex, AVG(math), COUNT(id) FROM student WHERE math > 70 GROUP BY sex;
  // 按照性别分组，分别查询男、女同学的平均分，人数。要求分数低于70分的人，不参与分组，分组之后，人数要大于2个人
  SELECT sex, AVG(math), COUNT(id) FROM student WHERE math > 70 GROUP BY sex HAVING COUNT(id) > 2;
  SELECT sex, AVG(math), COUNT(id) 人数 FROM student WHERE math > 70 GROUP BY sex HAVING 人数 > 2;
  // WHERE和HAVING的区别
  // WHERE在分组之前进行限定，如果不满足条件，则不参与分组。HAVING在分组之后进行限定，如果不满足结果，则不会被查询出来
  // WHERE后不可以跟聚合函数，HAVING可以进行聚合函数的判断
  
  // 分页查询
  // 语法：LIMIT 开始的索引, 每页查询的条数;
  // 公式：开始的索引 = (当前的页码 - 1) * 每页显示的条数
  -- 每页显示3条记录
  SELECT * FROM student LIMIT 0, 3;  -- 第1页
  SELECT * FROM student LIMIT 3, 3;  -- 第2页
  SELECT * FROM student LIMIT 6, 3;  -- 第3页
  // LIMIT是一个MYSQL“方言”
```
- **约束**
1. 概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性
2. 分类：  
```
  // 主键约束：PRIMARY KEY
  // 含义：非空且唯一
  // 一张表只能有一个字段为主键
  // 主键就是表中记录的唯一标识
  // 在创建表时，添加主键约束
  CREATE TABLE stu (
    id INT PRIMARY KEY,
    name VARCHAR(20)
  );
  // 删除主键
  // 错误写法 
  -- ALTER TABLE stu MODIFY id INT;
  // 正确写法
  ALTER TABLE stu DROP PRIMARY KEY;
  // 创建完表后，添加主键
  ALTER TABLE stu MODIFY id INT PRIMARY KEY;
  
  // 非空约束：NOT NULL
  // 创建表时添加约束
  CREATE TABLE stu (
    id INT,
    name VARCHAR(20) NOT NULL
  );
  // 创建表后，添加非空约束
  ALTER TABLE stu MODIFY name VARCHAR(20) NOT NULL;
  // 删除name的非空约束
  ALTER TABLE stu MODIFY name VARCHAR(20);
  
  // 唯一约束：UNIQUE 
  // 创建表时，添加唯一约束
  CREATE TABLE stu (
    id INT,
    phone_number VARCHAR(20) UNIQUE
  );
  // 注意MYSQL中，唯一约束限定的列的值可以有多个NULL
  // 删除唯一约束
  ALTER TABLE stu DROP INDEX phone_number;
  // 创建表后，添加唯一约束
  ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;
   
  // 外键约束：FOREIGN KEY
  // 让表与表产生关系，从而保证数据的正确性
  // 在创建表时，添加外键
  CREATE TABLE 表名 (
    ...
    外键列
    CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称)
  );
  // 删除外键
  ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
  // 创建表之后，添加外键
  ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);
  // 添加外键
  CREATE TABLE employee (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(20),
    age INT,
    dep_id INT,
    CONSTRAINT emp_dept_fk FOREIGN KEY (dep_id) REFERENCES department(id)
  );
  // 删除外键
  ALTER TABLE employee DROP FOREIGN KEY emp_dept_fk;
  
  // 级联操作
  // 添加级联操作
  ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE;
  // 分类
  ON UPDATE CASCADE -- 级联更新
  ON DELETE CASCADE -- 级联删除
  
  // 自动增长
  // 概念：如果某一列是数值类型的，使用AUTO_INCREMENT可以完成值的自动增长
  // 在创建表时，添加主键约束，并且完成自动增长
  CREATE TABLE stu (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(20)
  );
  // 删除自动增长
  ALTER TABLE stu MODIFY id INT;
  // 添加自动增长
  ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;
```
- **多表关系**
1. 一对多（多对一）  
如：部门和员工  
实现方式：在多的一方建立外键，指向一的一方的主键  
2. 多对多  
如：学生和课程  
实现方式：多对多关系实现需要借助第三章中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键
3. 一对一  
如：人和身份证  
实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键
- **三大范式**  
1. 第一范式（1NF）：每一列都是不可分割的原子数据项  
2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）  
3. 第三范式（3NF）：在2NF的基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）
4. 几个概念：  
a. 函数依赖：A-->B，如果通过A属性（属性组）的值，可以唯一确定B属性的值，则称B依赖于A  
例如：学号-->姓名，(学号, 课程名称)-->分数  
b. 完全函数依赖：A-->B，如果A是一个属性组，则B属性值的确定需要依赖于A属性组所有的属性值  
例如：(学号, 课程名称)-->分数  
c. 部分函数依赖：A-->B，如果A是一个属性组，则B属性的确定只需要依赖于A属性组中的某一些值即可  
例如：(学号, 课程名称)-->姓名  
d. 传递函数依赖：A-->B，B-->C。如果通过A属性（属性组）的值，可以唯一确定B属性的值，再通过B属性（属性组）的值可以唯一确定C属性的值，则称C传递函数依赖于A  
例如：学号-->系名，系名-->系主任  
e. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性组）为该表的码  
例如：该表中码为：(学号, 课程名称)  
主属性：码属性组中的所有属性  
非主属性：除过码属性组的属性  
5. 案例  
a. 原表    
![](./Pics/第一范式1.png)  
b. 1NF  
![](./Pics/第一范式2.png)  
c. 2NF  
![](./Pics/第二范式1.png)  
![](./Pics/第二范式2.png)  
d. 3NF  
![](./Pics/第三范式1.png)  
![](./Pics/第三范式2.png)  
- **数据库的备份和还原**  
1. 备份：`mysqldump -u用户名 -p密码 数据库名称 > 保存的路径`  
2. 还原：
a. 登录数据库  
b. 创建数据库  
c. 使用数据库  
d. 执行文件 `source 文件路径`  
- **多表查询**  
1. 内连接查询：
```
  // 隐式内连接：使用WHERE条件消除无用数据
  // 查询所有员工信息和对应的部门信息
  SELECT * FROM emp, dept WHERE emp.dept_id = dept.id;
  // 查询员工表的名称，性别，部门表的名称
  SELECT emp.name, emp.gender, dept.name FROM emp, dept WHERE emp.dept_id = dept.id;
  SELECT
    t1.name,
    t1.gender,
    t2.name
  FROM
    emp t1,
    dept t2
  WHERE
    t1.dept_id = t2.id;
    
    // 显式内连接：
    SELECT 字段列表 FROM 表名1 [INNER] JOIN 表名2 ON 条件
    // 例子
    SELECT * FROM emp INNER JOIN dept ON emp.dept_id = dept.id;
    SELECT * FROM emp JOIN dept ON emp.dept_id = dept.id;
```
2. 外连接查询：
```
  // 左外连接，查询的是作表所有数据以及其交集部分
  SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;
  // 右外连接，查询的是右表所有数据以及其交集部分
  SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;
  // 例子
  SELECT t1.*, t2.name FROM emp t1 LEFT JOIN dept t2 ON t1.dept_id = t2.id;
  SELECT t1.*, t2.name FROM emp t1 RIGHT JOIN dept t2 ON t1.dept_id = t2.id;
  SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.dept_id = t2.id;
```
3. 子查询：
```
  // 查询中嵌套查询，称嵌套查询为子查询
  // 查询工资最高的员工信息
  // 1. 查询最高的工资是多少 9000
  SELECT MAX(salary) FROM emp;
  // 2. 查询员工信息，并且工资等于9000的
  SELECT * FROM emp WHERE emp.salary = 9000;
  // 一条SQL就完成这个操作，子查询
  SELECT * FROM emp WHERE emp.salary = (SELECT MAX(salary) FROM emp);
  
  // 子查询不同情况
  // 1. 子查询的结果是单行单列的：
  // 子查询可以作为条件，使用运算符去判断（> >= < <=）
  // 查询员工工资小于平均工资的人
  SELECT * FROM emp WHERE emp.salary < (SELECT AVG(salary) FROM emp);
  // 2. 子查询的结果是多行单列的：
  // 子查询可以作为条件，使用运算符IN来判断
  // 查询'财务部'和'市场部'所有的员工信息
  SELECT id FROM dept WHERE name = '财务部' OR name = '市场部';
  SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;
  // 子查询
  SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE name = '财务部' OR name = '市场部');
  // 3. 子查询的结果是多行多列的：
  // 子查询可以作为一张虚拟表参与查询
  // 查询员工入职日期是2011-11-11日之后的员工信息和部门信息
  // 子查询
  SELECT * FROM dept t1, (SELECT * FROM emp WHERE emp.join_date > '2011-11-11') t2 WHERE t1.id = t2.dept_id;
  // 普通内连接
  SELECT * FROM emp t1, dept t2 WHERE t1.dept_id = t2.id AND t1.join_date > '2011-11-11';
```
- **事务**
1. 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败
2. 操作：  
a. 开启事务：`start transaction;`  
b. 回滚：`rollback;`  
c. 提交：`commit;`
3. 例子
```
  CREATE TABLE account (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(10),
    balance DOUBLE
  );
  // 添加数据
  INSERT INTO account (name, balance) VALUES ('zhangsan', 1000), ('lisi', 1000);
  SELECT * FROM account;
  UPDATE account SET balance = 1000;
  // 张三给李四转账500元
  // 0. 开启事务
  STRAT TRANSACTION;
  // 1. 张三账户-500
  UPDATE account SET balance = balance - 500 WHERE name = 'zhangsan';
  // 2. 李四账户+500
  UPDATE account SET balance = balance + 500 WHERE name = 'lisi';
  // 发现执行没有问题，提交事务
  COMMIT;
  // 发现出问题了，回滚事务
  ROLLBACK;
```
4. MySQL数据库中事务默认自动提交  
a. 事务提交的两种方式：  
自动提交：MySQL就是自动提交的，一条DML（增删改）语句会自动提交一次事务  
手动提交：Oracle数据库默认是手动提交事务，需要先开启事务再提交  
b. 修改事务的默认提交方式：  
查看事务的默认提交方式`SELECT @@AUTOCOMMIT;`：1代表自动提交，0代表手动提交  
修改默认提交方式：`SET @@AUTOCOMMIT = 0;`
